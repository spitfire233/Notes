\documentclass[12pt]{article}

\usepackage{booktabs}% http://ctan.org/pkg/booktabs
\usepackage[utf8]{inputenc}
\usepackage{changepage}
\usepackage{pgfplots}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{biblatex}
\lstset{
  language=Python,
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  tabsize=4,
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces,
}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{graphicx}
\newenvironment{para}{\begin{adjustwidth}{13mm}{}}{\end{adjustwidth}}

\newcommand\tab[1][1cm]{\hspace*{#1}}

\newcommand{\tabitem}{\llap{\textbullet}}
\newcommand{\Hsquare}{%
\text{\fboxsep=-.2pt\fbox{\rule{0pt}{1ex}\rule{1ex}{0pt}}}%
}

\newtheorem{Definizione}{Definizione}[subsection]
\newtheorem{Lemma}{Lemma}[subsection]
\newtheorem{Teorema/Definizione}{Teorema/Definizione}[subsection]
\newtheorem{Corollario}{Corollario}[subsection]
\newtheorem{Teorema}{Teorema}[subsection]
\newtheorem{Proposizione}{Proposizione}[subsection]
\newtheorem{Notazione}{Notazione}[subsection]
\newtheorem{Commento}{Commento}[subsection]
\newtheorem{Dimostrazione}{Dimostrazione}[subsection]
\newtheorem{Osservazione}{Osservazione}[subsection]
\newtheorem{Nota}{Nota}[subsection]

\title{RSO: Sistemi Operativi}
\author{spitfire}
\date{A.A. 2023-2024}
\begin{document}
\begin{figure}
    \centering
    \includegraphics[width=0.35\textwidth]{Images/Logo scienze bicocca.png}
\end{figure}

\vspace{10cm}
\date{A.A. 2023-2024}


\maketitle

\newpage

\tableofcontents
\newpage

\section{Struttura e servizi}
Cosa sappiamo sui sistemi operativi? Sappiamo che, per esempio, i principali sono
\textbf{linux, Windows e MacOS}; che il sistema operativo è il 
\textbf{primo programma che viene eseguito dopo il boot}. Di solito un sistema operativo
fornisce un \textbf{ambiente desktop a finestre e ci permette di installare nuove applicazioni}.
Ci permette inoltre di eseguire tante applicazioni \textbf{contemporaneamente}, anche più dei \textbf{core dei processori}.
Inoltre, esso \textbf{mantiene e organizza i nostri dati sotto forma di file e cartelle}.
Quindi, cos'è un \textbf{sistema operativo}? Esso è:
\begin{itemize}
    \item Un insieme di \textbf{programmi} (Software)
    \item Che gestiscono \textbf{gli elementi fisici di un computer} (Hardware)
\end{itemize}
E a \textbf{cosa serve un sistema operativo}?
\begin{itemize}
    \item Fornire una \textbf{piattaforma di sviluppo per le applicazioni}, che permette loro di \textbf{condividere e astrarre} le risorse HW.
    \item Agisce da \textbf{intermediario} tra utenti e computer, permettendo agli utenti di \textbf{controllare l'esecuzione dei programmi applicativi} e l'assegnazione delle risorse HW ad essi
    \item \textbf{Protegge le risorse degli utenti} (e dei loro programmi) dagli altri utenti (e dai loro programmi) e da eventuali \textbf{attori esterni}
\end{itemize}
Un sistema operativo è quindi in primo luogo una \textbf{piattaforma di sviluppo}, ossia un insieme di funzionalità software che i programmi applicativi possono usare.
Tali funzionalità permettono ai programmi di poter usare in maniere conveniente le risorse hardware di condividerle:
\begin{itemize}
    \item Da un lato il sistema operativo \textbf{astrae} le risorse hardware, presentando agli sviluppatori di programmi applicativi una visione delle risorse hardware più facile da usare e più potente rispetto alle risorse hardware "native".
    \item Dall'altro, il sistema operativo \textbf{condivide} le risorse hardware tra molti programmi contemporaneamente in esecuzione, suddividendole tra i programmi in maniera equa ed efficiente e controllando che questi le usino correttamente.
\end{itemize}
\subsection{Componenti di un sistema di elaborazione}
Le componenti di un sistemi di elaborazione sono:
\begin{itemize}
    \item \textbf{Utenti}: Persone, macchine, altri computer, ecc...
    \item \textbf{Programmi applicativi}: Risolvono i problemi di calcolo degli utenti
    \item \textbf{Sistema operativo}: Coordina e controlla l'uso delle risorse hardware
    \item \textbf{Hardware}: Risorse di calcolo (CPU, periferiche, memoria di massa, ...)
\end{itemize}
\begin{center}
    \includegraphics[width = 0.50\textwidth]{Images/1.PNG}
\end{center}
\subsection{Requisiti per i sistemi operativi}
Oggigiorno i computer sono ovunque: vi sono molteplici tipologie di computer utilizzati in scenari
applicativi molto diversi. In quasi tutti i tipi di computer si tende ad installare un sistema operativo allo scopo
di gestire l'hardware e semplificare la programmazione. Ma ogni scenario applicativo in cui viene usato un computer
richiede che il sistema operativo che vi viene installato abbia caratteristiche ben determinate. Che cosa si richiede quindi
ad un sistema operativo per supportare uno determinato scenario applicativo?
Vediamo qualche scenario:
\begin{itemize}
    \item \textbf{Server e Mainframe}: massimizzare le performance, rendere equa la condivisione delle risorse tra molti utenti
    \item \textbf{Laptop, PC e tablet}: massimizzare la facilità d'uso e la produttività della singola persona che lo usa
    \item \textbf{Dispositivi mobili}: Ottimizzare i consumi energetici e la connettività
    \item \textbf{Sistemi embedded}: funzionare senza, o con minimo, intervento umano e reagire in tempo reale agli stimoli esterni (interrupt)
\end{itemize}
\subsection{La maledizione della generalità}
Nella storia (ed anche oggi) alcuni sistemi operativi sono stati utilizzati per scenari applicativi diversi.
Ad esempio, Linux è usato oggi nei server, nei computer desktop e nei dispositivi mobili (come parte di Android).
La \textbf{maledizione della generalità} afferma che, se un sistema operativo deve supportare un insieme di scenari applicativi troppo ampio,
non sarà in grado di supportarne nessuno particolarmente bene. Esempio di questo si è visto con \textbf{OS/360}, il primo sistema operativo che doveva supportare
una famiglia di computer diversi (la linea 360 IBM).
\subsection{Struttura dei sistemi operativi}
Non c'è una definizione universalmente accettata di quali programmi fanno pare di un sistema operativo. In generale però un sistema operativo almeno comprende:
\begin{itemize}
    \item \textbf{Kernel}: Il "programma sempre presente" che si "impadronisce" dell'HW, lo gestisce, ed offre ai programmi i servizi per poterlo usare in maniera condivisa ed astratta
    \item \textbf{Middleware}: servizi di alto livello che astraggono ulteriormente i servizi del kernel e semplificano la programmazione di applicazioni (API, framework per grafica e per suono,...)
    \item \textbf{Programmi di sistema}: Non sempre in esecuzione, offrono ulteriori funzionalità di supporto e di interazione utente con il sistema (gestione di processi e jobs, UI, ...)
\end{itemize}
Alcuni sistemi operativi forniscono "out-of-the-box" anche dei \textbf{programmi applicativi} (editor, fogli di calcolo,...) ma non li considereremo come parti del sistema operativo.
Data questa lista di componenti, possiamo rivisitare le \textbf{componenti di un sistema di elaborazione}:
\begin{center}
    \includegraphics[width = 0.55\textwidth]{Images/2.PNG}
\end{center}
Che visti in dettaglio diventano:
\begin{center}
    \includegraphics[width = 0.63\textwidth]{Images/3.PNG}
\end{center}
\subsection{Servizi offerti da un sistema operativo}
I principali servizi che un sistema operativo offre sono:
\begin{itemize}
    \item \textbf{Controllo processi}: questi servizi permettono di caricare in memoria un programma, eseguirlo, identificare la sua terminazione e registrarne la condizione di terminazione (normale o erronea)
    \item \textbf{Gestione dei file}: questi servizi permettono di leggere, scrivere e manipolare files e directories
    \item \textbf{Gestione dispositivi}: questi servizi permettono ai programmi di effettuare operazioni di input/output, ad esempio leggere da/scrivere su un terminale
    \item \textbf{Comunicazione interprocesso}: i programmi in esecuzione possono collaborare tra di loro scambiandosi informazioni: questi servizi permettono ai programmi in esecuzione di comunicare
    \item \textbf{Protezione e sicurezza}: permette ai proprietari delle informazioni in un sistema multiutente o in rete di controllarne l'uso da parte di altri utenti e di difendere il sistema dagli accessi illegali
    \item \textbf{Allocazione delle risorse}: alloca le risorse hardware (CPU, memoria, dispositivi di I/O) ai programmi in esecuzione in maniera equa ed efficiente
    \item \textbf{Rilevamento errori}: gli errori possono avvenire nell'hardware o nel software  (es. divisione per 0); quando avvengono il sistema operativo deve intraprendere opportune azioni (recupero, terminazione del programma o segnalazione della condizione di errore al programma)
    \item \textbf{Logging}: mantiene traccia di quali programmi usano quali risorse, allo scopo di contabilizzarle
\end{itemize}
\subsection{Chiamate di sistema e Application Programming Interfaces}
\begin{center}
    \includegraphics[width = 0.50\textwidth]{Images/4.PNG}
\end{center}
Il kernel offre i propri servizi ai programmi come \textbf{chiamate di sistema} (syscalls), ossia funzioni invocabili in un determinato linguaggio di programmazione (C, C++, ...).
I programmi però non utilizzano direttamente le chiamate di sistema, ma delle librerie di middleware dette \textbf{Application Programming Interface} (API) implementate invocando le chiamate di sistema.
Spesso le API sono fortemente legate con le librerie standard del linguaggio di implementazione (es. libc se le API sono implementate in C) al punto che anche queste diventano parte implicita dell'API.
Bisogna ricordare che:
\begin{itemize}
    \item Le API sono \textbf{esposte dal middleware}, mentre le chiamate di sistema \textbf{dal kernel}
    \item Le API usano le chiamate di sistema nella loro implementazione
    \item Le API sono standardizzate (es. POSIX, Win32), le chiamate di sistema no, quindi ogni kernel ha chiamate di sistema differenti
    \item Le API sono stabili, le chiamate di sistema possono variare al variare della versione del sistema operativo
    \item Le API offrono funzionalità più ad alto livello e più semplici da usare, le chiamate di sistema offrono funzionalità più elementari e più complesse da usare
\end{itemize}
\begin{center}
    \includegraphics[width = 0.75\textwidth]{Images/5.PNG}
\end{center}
\subsection{Programmi di sistema}
La maggior parte degli utenti utilizza servizi del sistema operativo attraverso i programmi di sistema.
Questi permettono agli utenti di avere un ambiente più conveniente per l'esecuzione dei programmi, il loro sviluppo e la gestione delle risorse del sistema.
Vi sono diversi tipi di programmi di sistema:
\begin{itemize}
    \item \textbf{Interfacce utente (UI)}: permette agli utenti di interagire con il sistema stesso; può essere grafica (GUI) o a riga di comando (CLI); i sistemi mobili hanno un'interfaccia touch.
    \item \textbf{Gestione file}: creazione, modifica e cancellazione di file e directories
    \item \textbf{Modifica dei file}: editor di testo, programmi per la manipolazione del contenuto dei file (Emacs)
    \item \textbf{Visualizzazione e modifica informazioni di stato}: data, ora, memoria disponibile, processi, utenti, ... fino a informazioni complesse su prestazione, accessi al sistema e debug. Alcuni sistemi implementano un \textbf{registry}, ossia un database delle informazioni di configurazione
    \item \textbf{Caricamento ed esecuzione dei programmi}: loader assoluti e rilocabili, linker e debugger
    \item \textbf{Ambienti di supporto alla programmazione}: compilatori, assemblatori, debugger, interpreti per diversi linguaggi di programmazione
    \item \textbf{Comunicazione}: forniscono i meccanismi per creare connessione tra utenti, programmi e sistemi; permettono di inviare messaggi agli schermi di un altro utente, di navigare il web, di inviare messaggi di posta elettronica, di accedere remotamente ad un altro computer, di trasferire i file, ecc...
    \item \textbf{Servizi di background}: lanciati all'avvio, alcuni terminano, altri continuano l'esecuzione fino allo shutdown. Forniscono servizi quali verifica dello stato dei dischi, scheduling di jobs, logging, ...
\end{itemize}
\subsubsection{Intefaccia utente: l'interpete dei comandi}
\begin{center}
    \includegraphics[width = 0.75\textwidth]{Images/6.PNG}
\end{center}
L'interprete dei comandi permette agli utenti di impartire in maniera testuale delle istruzioni al sistema operativo.
In molti sistemi operativi è possibile configurare quale interprete dei comandi usare, nel qual caso è detto \textbf{shell}.
Ci sono due modi per implementare un comando:
\begin{itemize}
    \item \textbf{Built-in}: l'interprete esegue direttamente il comando (tipico dell'interprete dei comandi di Windows)
    \item \textbf{Come programma di sistema}: l'interprete manda in esecuzione un programma (tipico delle shell Unix e Unix-Like)
\end{itemize}
Spesso l'interprete riconosce \textbf{un vero e proprio linguaggio di programmazione} (es. Bash).
\subsubsection{Interfaccia utente: le interfacce grafiche}
\begin{center}
    \includegraphics[width = 0.85\textwidth]{Images/7.png}
\end{center}
Le interfacce grafiche(GUI) sono di solito basate sulla metafora della scrivania, delle icone e delle cartelle (corrispondenti alle directory).
Nate dalla ricerca presso lo Xerox PARC lab negli anni 70, vennero popolarizzate dai computer Apple Macintosh negli anni 80. Su Linux le più popolari sono KDE e Gnome.
\newpage
\subsubsection{Intefaccia utente: Le interfacce touch-screen}
\begin{center}
    \includegraphics[width = 0.30\textwidth]{Images/8.PNG}
\end{center}
I dispositivi mobili richiedono interfacce di nuovo tipo. Esse non prevedono nessun dispositivo di puntamento (mouse); sostituendolo con l'uso dei gesti (gestures).
Inoltre esse possono offrire servizi come tastiere virtuali e comandi vocali.
\subsection{L'implementazione dei programmi di sistema}
\begin{center}
    \includegraphics[width = 0.55\textwidth]{Images/9.PNG}
\end{center}
I programmi di sistema sono implementati utilizzando le API, esattamente come i programmi applicativi.
Consideriamo ad esempio il comando \textit{cp} delle shell dei sistemi operativi Unix-like; la sua sintassi è:
\begin{center}
    \textit{cp in.txt out.txt}
\end{center}
Esso copia il contenuto del file \textit{in.txt} in un file \textit{out.txt}. Se il file \textit{out.txt} esiste, il contenuto precedente viene cancellato, altrimenti \textit{out.txt} viene creato.
L'immagine sopra rappresenta una possibile struttura del codice; le invocazioni delle API sono riportate in grassetto.
\textit{cp} è implementato come programma di sistema.
\section{Processi e thread: i servizi}
Un sistema operativo esegue un certo numero di programmi sullo stesso sistema di elaborazione.
Il numero di programmi da eseguire può essere arbitrariamente elevato, di solito è infatti molto maggiore del numero di CPU del sistema.
A tale scopo, il sistema operativo realizza e mette a disposizione un'astrazione detta \textbf{processo}. Un processo è quindi un'entità attiva astratta definita dal sistema operativo allo scopo di eseguire un programma.
Per il momento, assumiamo che l'esecuzione di un processo sia sequenziale, tuttavia \textbf{rilasseremo presto questa assunzione}.
\subsection{Programmi e processi}
È fondamentale notare la differenza tra programma e processo!
\begin{itemize}
    \item Un programma è un'entità passiva (un insieme di istruzioni, tipicamente contenuto in un file sorgente o eseguibile)
    \item Un processo è un'entità attiva (è un \textbf{esecutore di un programma} o un \textbf{programma in esecuzione})
\end{itemize}
Uno stesso programma può dare origine a \textbf{diversi processi}:
\begin{itemize}
    \item Diversi utenti eseguono lo stesso programma
    \item Uno stesso programma viene eseguito più volte, anche contemporaneamente, dallo stesso utente
\end{itemize}
\subsection{Struttura di un processo}
Un processo è composto da diverse parti:
\begin{itemize}
    \item Lo stato dei registri del processore che esegue il programma, incluso il PC
    \item Lo stato della \textbf{immagine} del processo, ossia della regione di memoria centrale usata dal programma
    \item Le risorse del sistema operativo in uso al programma (files, locks, ...)
    \item Più diverse informazioni sullo stato del processo per il sistema operativo
\end{itemize}
Notare che processi distinti hanno immagini distinte! Due processi operano su zone di memoria centrale separate!
Le risorse del sistema operativo invece possono essere condivise tra processi (a seconda del tipo di risorsa)
\subsubsection{L'immagine di un processo}
L'intervallo di indirizzi di memoria in cui è contenuta l'immagine di un processo è anche detto \textbf{spazio di indirizzamento} (\textbf{address space}) del processo.
L'immagine di un processo di norma contiene:
\begin{itemize}
    \item \textbf{Text section}: contiene il codice macchina del programma
    \item \textbf{Data section}: contiene le variabili globali
    \item \textbf{Heap}: contiene la memoria allocata dinamicamente durante l'esecuzione
    \item \textbf{Stack delle chiamate}: contiene parametri, variabili locali e indirizzo di ritorno delle varie procedure che vengono invocate durante l'esecuzione del programma
\end{itemize}
\begin{center}
    \includegraphics[width = 0.35\textwidth]{Images/10.PNG}
\end{center}
Text e data section hanno dimensioni costanti per tutta la vita del processo; mentre stack e heap invece crescono e decrescono durante la vita del processo.
\subsection{Operazioni sui processi}
I sistemi operativi di solito forniscono delle chiamate di sistema con le quali un processo può creare, terminare e manipolare altri processi.
Dal momento che solo un processo può creare un altro processo, all'avvio il sistema operativo crea dei processi \textbf{primordiali} dai quali tutti i processi utente e di sistema vengono progressivamente creati.
\subsubsection{Creazione di processi}
Di solito nei sistemi operativi i processi sono organizzati in maniera \textbf{gerarchica}:
Un processo \textbf{padre} può creare altri processi \textbf{figli} che a loro volta potranno essere i padri di nuovi processi.
Ciò va a creare un \textbf{albero di processi}
\begin{center}
    \includegraphics[width = 0.74\textwidth]{Images/11.PNG}
\end{center}
La relazione padre/figlio è di norma importante per le politiche di condivisione delle risorse e di coordinazione tra processi.
Vi sono diverse \textbf{politiche di condivisione di risorse}:
\begin{itemize}
    \item Padre e figlio condividono \textbf{tutte le risorse}...
    \item ...o un \textbf{opportuno sottoinsieme}...
    \item ...o \textbf{nessuna risorsa}
\end{itemize}
Quando un processo padre crea un processo figlio, esso può adottare diverse \textbf{politiche di creazione di spazio di indirizzi}:
\begin{itemize}
    \item Il figlio è un \textbf{duplicato} del padre (stessa memoria e programma1)...
    \item oppure no, e bisogna \textbf{specificare quale programma deve eseguire il figlio}
\end{itemize}
I processi padri e i loro figli possono inoltre \textbf{coordinarsi fra loro} seguendo delle \textbf{politiche di coordinazione padre/figli}:
\begin{itemize}
    \item Il padre è \textbf{sospeso} finché i figli non terminano...
    \item oppure eseguono in maniera \textbf{concorrente}
\end{itemize}
\subsubsection{Terminazione di processi}
I processi di regola richiedono esplicitamente la propria terminazione al sistema operativo. 
Un processo padre può attendere o meno la terminazione di un figlio oppure la \textbf{può forzare} per una serie di ragioni:
\begin{itemize}
    \item Il figlio sta usando \textbf{risorse in eccesso} (tempo, memoria, ...)
    \item Le funzionalità del figlio \textbf{non sono più richieste} (in questo caso, tuttavia, è meglio terminarlo in maniera ordinata tramite IPC)
    \item Il padre \textbf{termina prima del figlio} (in alcuni S.O.)
\end{itemize}
Riguardo all'ultimo punto, alcuni sistemi operativi \textbf{non permettono che i processi figli esistano se il loro processo padre è terminato}:
\begin{itemize}
    \item \textbf{Terminazione a cascata}: anche i nipoti, pronipoti, ecc... devono essere terminati
    \item La terminazione viene iniziata dal \textbf{sistema operativo}
\end{itemize}
\subsection{API POSIX per le operazioni sui processi}
\textbf{POSIX} (Portable Operating System Interface for Unix) è una famiglia di standard specificata dalla \textbf{IEEE} per mantenere la compatibilità del software tra diversi sistemi operativi,
in particolare tra le varianti di Unix (Linux e MacOS per esempio). In particolare definisce l'API disponibile (come la libreria \textbf{C POSIX} per il linguaggio C) e l'interfaccia a linea di comando
utilizzabile per shell (come \textbf{bash} e \textbf{dash}) e altri comandi fondamentali.
Un sistema operativo che segue gli standard POSIX si dice \textbf{POSIX-Compliant}.
Per operare sui processi, POSIX definisce le seguenti API:
\begin{itemize}
    \item \textbf{fork()}: Crea un nuovo processo figlio; il figlio è un duplicato del padre ed esegue concorrentemente ad esso; ritorna al padre un \textbf{numero identificatore} (PID) del processo figlio e al figlio il PID 0.
    \item \textbf{exec()}: Sostituisce il programma in esecuzione da un processo con un altro programma, che viene \textbf{eseguito dall'inizio}; viene tipicamente usato dopo una fork() dal figlio per iniziare ad eseguire un programma diverso da quello del padre.
    exec() tuttavia definisce un intera \textbf{famiglia di funzioni} in POSIX, ognuna distinta da dei \textbf{suffissi} di cui ogni lettera ha un significato particolare:
    \begin{itemize}
        \item \textbf{e}: Un \textbf{array di puntatori a variabili d'ambiente} è passato esplicitamente alla nuova immagine del processo
        \item \textbf{l}: Gli argomenti passati \textbf{da linea di comando} sono passati individualmente (come lista) alla funzione
        \item \textbf{p}: Utilizza la variabile d'ambiente \textbf{PATH} per trovare il file nominato nell'argomento "file" per eseguirlo
        \item \textbf{v}: Gli argomenti passati \textbf{da linea di comando} sono passati come un array di puntatori
    \end{itemize}
    Tendenzialmente, gli argomenti di una exec() sono:
    \begin{itemize}
        \item Il \textbf{path} del programma da eseguire oppure il \textbf{file descriptor} (fd) del file da eseguire
        \item Gli \textbf{argomenti} da passare all'entry point del programma da eseguire
    \end{itemize}
    \item \textbf{wait()}: viene chiamata dal padre per attendere la fine dell'esecuzione di un figlio; ritorna:
    \begin{itemize}
        \item il \textbf{PID} del figlio che è terminato
        \item Il codice di ritorno del figlio (passato come parametro dal figlio in \textbf{exit()})
    \end{itemize}
    \item \textbf{exit()}: fa terminare il processo che la invoca:
    \begin{itemize}
        \item Accetta come parametro un codice di ritorno numerico
        \item Il sistema operativo elimina il processo e recupera le sue risorse
        \item Quindi restituisce al processo padre il codice di ritorno (se ha invocato wait(), altrimenti lo memorizza per quando lo invocherà)
        \item Viene implicitamente invocata se il processo esce dalla funzione main
    \end{itemize}
    \item \textbf{abort()}: fa terminare forzatamente un processo figlio
\end{itemize}
Tendenzialmente la tipica sequenza di fork-exec è rappresentabile come segue:
\begin{center}
    \includegraphics[width = 1\textwidth]{Images/12.PNG}
\end{center}
\subsection{Processi zombie e orfani}
Se un processo termina ma il suo padre non lo sta aspettando (cioè non ha invocato wait()), il processo è detto essere \textbf{zombie}:
le sue risorse non possono essere completamente deallocate (il padre potrebbe prima o poi invocare wait()).
Se un processo padre termina prima di un suo figlio e \textbf{non vi è terminazione a cascata} allora i suoi processi figli si dicono \textbf{orfani}.
\subsection{Comunicazione interprocesso}
Più processi possono essere indipendenti o cooperare. Un processo coopera con uno o più altri processi se il suo comportamento "influenza" o "è influenzato da" il comportamento di questi ultimi.
Vi sono più motivi per il quale si vogliono avere processi cooperanti:
\begin{itemize}
    \item \textbf{Condivisione} di informazioni
    \item \textbf{Accelerazione} di computazioni
    \item \textbf{Modularità} e \textbf{isolamento} (come in Chrome)
\end{itemize}
Per permettere ai processi di cooperare il sistema operativo deve mettere a disposizione primitive di \textbf{comunicazione interprocesso} (IPC).
Vi sono due tipi di primitive:
\begin{itemize}
    \item \textbf{Memoria condivisa}
    \item \textbf{Message passing}
\end{itemize}
\subsubsection{Modelli di IPC}
\begin{center}
    \includegraphics[width = 0.65\textwidth]{Images/13.PNG}
\end{center}
\subsubsection{IPC tramite memoria condivisa}
Nella IPC tramite memoria condivisa viene stabilita una zona di memoria condivisa tra i processi che intendono comunicare.
La comunicazione è \textbf{controllata dai processi che comunicano} e non dal sistema operativo.
Un problema importante è permette ai processi che comunicano tramite memoria condivisa di \textbf{sincronizzarsi} (un processo non deve leggere la memoria condivisa mentre l'altro sta scrivendo).
Allo scopo, i sistemi operativi mettono a disposizione ulteriori primitive per la \textbf{sincronizzazione}.
\subsubsection{IPC tramite message passing}
Nell'IPC tramite message passing, si permette ai processi \textbf{sia di comunicare che di sincronizzarsi}.
I processi comunicano tra di loro \textbf{senza condividere memoria} attraverso la mediazione del sistema operativo.
Questo mette a disposizione:
\begin{itemize}
    \item Un'operazione \textbf{send(message)} con la quale un processo può inviare un messaggio ad un altro processo
    \item Un'operazione \textbf{receive(message)} con la quale un processo può ricevere un messaggio o mettersi in attesa fino a quando non ne riceve uno.
\end{itemize}
Per comunicare fra loro, due processi devono:
\begin{itemize}
    \item Stabilire un \textbf{link di comunicazione} tra di loro
    \item Scambiarsi \textbf{messaggi} usando \textit{send} e \textit{receive}
\end{itemize}
\subsubsection{Pipe}
Le \textbf{pipe} sono canali di comunicazione tra i processi e sono una forma di IPC tramite \textbf{message passing}.
Ve ne sono di vario tipo:
\begin{itemize}
    \item \textbf{Unidirezionale}
    \item \textbf{Bidirezionale}
    \begin{itemize}
        \item \textbf{Half-Duplex}
        \item \textbf{Full-Duplex}
    \end{itemize}
    \item \textbf{Relazione} tra i processi comunicanti (sono padre-figlio oppure no)
    \item Usabili o meno in \textbf{rete}
\end{itemize}
Convenzionalmente, le pipe sono:
\begin{itemize}
    \item \textbf{Unidirezionali}
    \item Non accessibili al di fuori del processo creatore; sono quindi di solito \textbf{condivise} con un processo figlio attraverso una \textbf{fork()}
    \item In Windows sono chiamate \textbf{pipe anonime}
\end{itemize}
Vi sono anche le \textbf{named pipes}:
\begin{itemize}
    \item \textbf{Bidirezionali}
    \item Esistono anche \textbf{dopo la terminazione} del processo che le ha create 
    \item Non richiedono una relazione padre-figlio tra i processi che la usano
\end{itemize}
In \textbf{Unix}, le named pipes sono:
\begin{itemize}
    \item Half-duplex
    \item Sono accessibili solo sulla stessa macchina
    \item Trasportano solo dati byte-oriented
\end{itemize}
In \textbf{Windows} invece, le named pipes sono:
\begin{itemize}
    \item Full-duplex
    \item Sono accessibili anche da macchine diverse
    \item Trasportano anche dati message-oriented
\end{itemize}
\subsubsection{Notifiche con callback}
In alcuni sistemi operativi (es. API POSIX e Win32) un processo può \textbf{notificare} un altro processo in maniera da causare \textbf{l'esecuzione di un blocco di codice} ("callback"), similmente a 
ciò che avviene durante un \textbf{interrupt}.
Nei sistemi Unix-like (POSIX, Linux) tale notifiche vengono dette \textbf{segnali} ed interrompono in maniera \textbf{asincrona} la computazione del processo corrente,
causando un \textbf{salto brusco alla callback di gestione}, al termine della quale la computazione \textbf{ritorna al punto di interruzione}.
Nelle API Win32 esiste un meccanismo simile, detto \textbf{Asynchronous Procedure Call} (APC), che però richiede che il ricevente si metta \textbf{esplicitamente in uno stato di attesa} e che esponga un servizio che il mittente possa invocare.
\subsection{API POSIX per l'IPC}
\subsubsection{Memoria condivisa in POSIX}
Un processo crea o apre un segmento di memoria condivisa con la funzione \textit{smh\_open}:
\begin{center}
    \textit{int shm\_fd = shm\_open(const char *name, int oflag, mode\_t mode);}
\end{center}
dove:
\begin{itemize}
    \item Il parametro \textbf{oflag} può avere i seguenti valori:
    \begin{itemize}
        \item \textbf{O\_RDONLY}: Apertura in sola lettura
        \item \textbf{O\_RDWR}: Apertura per lettura o scrittura
        \item \textbf{O\_CREAT}: Crea lo spazio di memoria condivisa
        \item \textbf{O\_EXCL}: Se \textbf{O\_EXCL} e \textbf{O\_CREAT} sono settate; allora \textit{shm\_open} fallisce se l'oggetto di memoria condivisa con quel nome esiste già. Se invece Se \textbf{O\_EXCL} è settata ma non Se \textbf{O\_CREAT} allora il risultato è \textbf{indefinito}
        \item \textbf{O\_TRUNC}: Se l'oggetto esiste ed è stato aperto con successo tramite \textbf{O\_RDWR}, allora l'oggetto sarà troncato a lunghezza 0.
        \item Si possono utilizzare \textbf{O\_RDONLY} e \textbf{O\_RDWR} in combinazione con le altre flag, ma non insieme.
    \end{itemize}
    \item Il parametro \textit{mode} indica invece la \textbf{modalità di accesso} con cui si sta accedendo all'oggetto di memoria condivisa.
    La modalità è quindi con quali \textbf{permessi} si accede all'oggetto ed essi sono rappresentati da una \textbf{maschera di bit} in base 8 (da 0 a 7).
    In UNIX, i permessi sono rappresentati tramite \textbf{3 triadi}, che rappresentano rispettivamente quali permessi sul file hanno \textbf{l'utente, i membri del gruppo e gli utenti "esterni al gruppo"}.
    Diamo una tabella di quelli più comuni:
    \begin{center}
        \includegraphics[width = 0.90\textwidth]{Images/14.PNG}
    \end{center}
\end{itemize}
Un esempio di chiamata è:
\begin{center}
    \textit{int shm\_fd = shm\_open(name, O\_CREAT | O\_RWDR, 0666)}
\end{center}
Quando si crea un nuovo segmento, è necessario \textbf{impostarne la dimensione}; ciò viene fatto tramite la funzione
\textbf{ftruncate} che ha firma:
\begin{center}
    \textit{int ftruncate(int fildes, off\_t length)}
\end{center}
Dove \textbf{fildes}, nel nostro caso, è il \textbf{file descriptor} del segmento di memoria e \textbf{length} sarà la dimensione
che gli vogliamo dare (in byte).
Infine, la funzione \textbf{mmap} mappa la memoria condivisa nello spazio:
\begin{center}
    \textit{void* mmap(void* addr, size\_t len, int prot, int flags, int flides, off\_t off);}
\end{center}
dove:
\begin{itemize}
    \item Il parametro \textbf{addr} è l'indirizzo di partenza dello spazio di memoria condivisa. Questo parametro viene in verità usato come
    \textbf{SUGGERIMENTO} da parte del kernel del sistema operativo; ciò accade perché lo spazio di indirizzi indicato da addr e len \textbf{potrebbe essere già allocato}.
    \item Il parametro \textbf{length} specifica la lunghezza (in byte) dello spazio di memoria allocato
    \item Il paramtero \textbf{prot} indica quali operazioni sono permesse sulla regione di memoria; esso può assumere:
    \begin{itemize}
        \item \textbf{PROT\_READ}: I dati possono essere letti
        \item \textbf{PROT\_WRITE}: I dati possono essere scritti
        \item \textbf{PROT\_EXEC}: I dati possono essere eseguiti
        \item \textbf{PROT\_NONE}: I dati non possono essere acceduti
    \end{itemize}
    \item Il paramtero \textbf{flag} fornisce ulteriori informazioni riguardo la gestione dei dati mappati sullo spazio di memoria. Esso può assumere:
    \begin{itemize}
        \item \textbf{MAP\_SHARED}: I cambiamenti sono condivisi
        \item \textbf{MAP\_PRIVATE}: I cambiamenti sono privati
        \item \textbf{MAP\_FIXED}: Quando questa flag è impostata, la regione di memoria allocata \textbf{parte esattamente da addr} al posto di usarlo come un suggerimento.
    \end{itemize}
    \item Il parametro \textbf{filedes} indica il file (o l'oggetto) che rappresenta lo spazio di memoria condivisa
    \item Il parametro \textbf{off} indica l'offset nel file da dove inizia lo spazio di memoria condivisa
\end{itemize}
Un'esempio di chiamata può essere:
\begin{center}
    \textit{void* shm\_ptr = mmap(0, 4096, PROT\_WRITE, MAP\_SHARED, shm\_fd, 0)}
\end{center}
Da questo momento si può quindi usare il puntatore shm\_ptr ritornato da mmap per leggere/scrivere la memoria condivisa.
\subsubsection{Pipe anonime in POSIX}
Le pipe anonime in POSIX vengono create con la funzione \textit{pipe}, che ritorna due descrittori, uno per punto di lettura e uno per il punto di scrittura.
Ipotizziamo quindi di avere un array \textit{int pd\_fd[2]}; la funzione \textit{pipe} ha la seguente firma:
\begin{center}
    \textit{pipe(int fildes[2])}
\end{center}
Con \textit{fildes[2]} l'array in cui verranno scritti i descrittori di lettura e scrittura (lettura nella cella 0 e scrittura nella cella 1). La funzione ritorna 0 se ha avuto successo, -1 altrimenti; in questo caso
verrà impostata la flag \textit{ERRNO} per indicare l'errore e i descrittori NON verranno allocati all'interno di \textit{fildes[2]}. Un esempio di chiamata di \textit{pipe} è:
\begin{center}
    \textit{int res = pipe(p\_fd)}
\end{center}
Le funzioni \textit{read} e \textit{write} permettono rispettivamente di leggere e scrivere: \newline
La funzione write ha la seguente firma:
\begin{center}
    \textit{ssize\_t write (int fildes, const void* buf, size\_t nbyte)}
\end{center}
Essa cercherà di scrivere \textit{nbyte} dal buffer puntato da \textit{buf} al file associato al file descriptor \textit{fildes}.
La funzione ritorna il numero di byte effettivamente scritto, altrimenti -1.
Una scrittura sulla pipe anonima d'esempio può essere quindi:
\begin{center}
    \textit{ssize\_t n\_wr = write(p\_fd[1], "Hello World!", 14);}
\end{center}
La funzione \textit{read} ha la seguente firma:
\begin{center}
    \textit{ssize\_t read(int fildes, void* buf, size\_t nbyte);}
\end{center}
La funzione cercherà di leggere \textit{nbyte} dal file associato al file descriptor \textit{fildes} e di porre ciò che ha letto
nel buffer puntato da \textit{buf}. La funzione restituirà il numero di byte letti se ha avuto successo, -1 altrimenti.
Un esempio di lettura dalla pipe anonima d'esempio può essere quindi:
\begin{center}
    \textit{char buffer[256];} \\
    \textit{ssize\_t n\_rd = read(p\_fd[0], buffer, sizeof(buffer) - 1);}
\end{center}
\subsubsection{Named Pipes in POSIX}
Le named pipes vengono anche chiamate \textbf{FIFO} nei sistemi POSIX. Per creare una FIFO, si utilizza l'API \textit{mkfifo}, che ha la seguente firma:
\begin{center}
    \textit{int mkfifo(const char *path, mode\_t mode);}
\end{center}
La funzione andrà a creare un nuovo file speciale FIFO con nome dato dal percorso puntato da \textit{path}.
I bit dei permessi del file saranno impostati come specificato in \textit{mode}.
La funzione ritorna 0 se la creazione del file avviene con successo, -1 altrimenti.
Un esempio di chiamata può quindi essere:
\begin{center}
    \textit{int res = mkfifo("/home/pietro/myfifo", 0640);}
\end{center}
La FIFO quindi potrà utilizzare come un normale file; in particolare possiamo aprirla tramite l'API \textit{open}:
\begin{center}
    \textit{int open(const char *path, int oflag, ...);}
\end{center}
La funzione quindi aprirà il file specificato in \textit{path}.
Il parametro \textit{flag} deve obbligatoriamente assumere uno dei seguenti valori:
\begin{itemize}
    \item \textbf{O\_RDONLY}: il file viene aperto in modalità di sola lettura
    \item \textbf{O\_WRONLY}: il file viene aperto in modalità di sola scrittura
    \item \textbf{O\_RDWR}: Il fine viene aperto ed è possibile effettuare su di esso sia le operazioni di lettura che di scrittura
\end{itemize}
Inoltre è possibile specificare, in OR bitwise (|) con uno dei valori di \textit{flag} sopra (cioè viene fatto l'or bit a bit dei valori), le seguenti flag:
\begin{itemize}
    \item \textbf{O\_APPEND}: Il file viene aperto in "append mode", cioè ogni scrittura viene fatta alla fine del file
    \item \textbf{O\_CLOEXEC}: Viene impostata, per questo file, la flag \textbf{FD\_CLOEXEC}, cioè il file verrà chiuso se un processo che lo gestisce usa una delle funzioni della famiglia \textit{exec} viene eseguita sul file
    \item \textbf{O\_CLOFORK}: Viene impostata, per questo file, la flag \textbf{FD\_CLOFORK}, cioè il file verrà chiuso se un processo che lo gestisce effettua una \textit{fork()}
    \item \textbf{O\_CREAT}: Se il \textbf{path} non esiste, lo crea come un file normale. (n.d.a Si faccia riferimento a \textit{man} o alla documentazione POSIX per una spiegazione più dettagliata)
    \item \textbf{O\_DIRECTORY}: Se \textit{path} risolve a un file che NON è una directory, questa flag porta la funzione a fallire
    \item \textbf{O\_EXCL}: Se \textbf{O\_CREAT} e \textbf{O\_EXCL} sono entrambe impostate, la funzione fallirà se il file già esiste. Se invece solo questa flag è impostata, il risultato è \textbf{indefinito}
    \item \textbf{O\_TRUNC}: Se il file esiste ed è un file normale e il file è stato aperto con successo in modalità "sola scrittura" (flag ha valore \textit{O\_WRONLY}) oppure in è aperto in "modalità lettura e scrittura" (flag ha valore \textit{O\_RDWR}), allora tutti i contenuti del file verranno troncati (cioè cancellati) e la sua lunghezza verrà impostata a 0.
\end{itemize}
Quindi, un esempio di apertura di una FIFO può essere il seguente:
\begin{center}
    \textit{int fd = open("/home/pietro/myfifo", O\_RDONLY);}
\end{center}
Poiché una FIFO può essere utilizzata come un file normale, possiamo anche usare le API \textit{read} e \textit{write} viste prima per leggere e scrivere su di essa:
\begin{center}
    \textit{char buffer[256];} \\
    \textit{ssize\_t n\_rd = read(fd, buffer, sizeof(buffer) - 1);}
\end{center}
Al termine dell'utilizzo, dobbiamo ricordarci di \textbf{chiudere la FIFO}; per farlo usiamo l'API \textbf{close}:
\begin{center}
    \textit{int close(int fildes)}
\end{center}
La funzione prende in input il file descriptor e lo chiude (cioè chiude il file).
La funzione ritorna 0 se ha successo, -1 se invece fallisce. Per chiudere la FIFO che abbiamo presentato fino a qui come esempio,
possiamo quindi procedere in questo modo:
\begin{center}
    \textit{close(fd);}
\end{center}
Per invece \textbf{eliminare} una FIFO, possiamo usare l'API \textbf{unlink}:
\begin{center}
    \textit{int unlink(const char* path)}
\end{center}
l'API, in generale, si comporta in maniera differente in base a \textbf{cosa viene specificato come valore di path}:
\begin{itemize}
    \item Se quel nome era \textbf{l'ultimo collegamento ad un file e nessun processo ha quel file aperto}, il file viene \textbf{eliminato} e lo spazio che stava usando viene reso disponibile per il riuso.
    Se invece il file è ancora in uso da parte di un processo, esso rimarrà in memoria fino a quando \textbf{l'ultimo file descriptor che lo referenzia non viene chiuso}.
    \item Se il nome specificato è un \textbf{link simbolico} (un collegamento), esso viene rimosso
    \item Se il nome si riferisce ad una \textbf{Socket}, una \textbf{FIFO} o ad un \textbf{dispositivo}, allora il nome viene rimosso, ma i processi che lo stavano usando \textbf{possono continuare a farlo}
\end{itemize} 
La funzione ritorna 0 se ha successo, altrimenti -1. Per eliminare quindi una FIFO usando \textit{unlink}, possiamo procedere nel seguente modo:
\begin{center}
    \textit{unlink("/home/pietro/myfifo");}
\end{center}
\subsubsection{Segnali in POSIX}
Possiamo inviare un segnale ad un processo utilizzando l'API \textit{kill}:
\begin{center}
    \textit{int kill(pid\_t pid, int sig)}
\end{center}
Dove \textit{pid} è l'ID del processo e \textit{sig} è il segnale che si vuole inviare.
I segnali che si possono inviare sono definiti nella libreria \textbf{signal.h}.
Un esempio di utilizzo può essere il seguente:
\begin{center}
    \textit{int ok = kill(1000, SIGERM);}
\end{center}
\end{document}
