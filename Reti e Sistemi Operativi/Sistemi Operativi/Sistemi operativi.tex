\documentclass[12pt]{article}

\usepackage{booktabs}% http://ctan.org/pkg/booktabs
\usepackage[utf8]{inputenc}
\usepackage{changepage}
\usepackage{pgfplots}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{biblatex}
\usepackage{float}
\lstset{
  language=Python,
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  tabsize=4,
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces,
}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{graphicx}
\newenvironment{para}{\begin{adjustwidth}{13mm}{}}{\end{adjustwidth}}

\newcommand\tab[1][1cm]{\hspace*{#1}}

\newcommand{\tabitem}{\llap{\textbullet}}
\newcommand{\Hsquare}{%
\text{\fboxsep=-.2pt\fbox{\rule{0pt}{1ex}\rule{1ex}{0pt}}}%
}

\newtheorem{Definizione}{Definizione}[subsection]
\newtheorem{Lemma}{Lemma}[subsection]
\newtheorem{Teorema/Definizione}{Teorema/Definizione}[subsection]
\newtheorem{Corollario}{Corollario}[subsection]
\newtheorem{Teorema}{Teorema}[subsection]
\newtheorem{Proposizione}{Proposizione}[subsection]
\newtheorem{Notazione}{Notazione}[subsection]
\newtheorem{Commento}{Commento}[subsection]
\newtheorem{Dimostrazione}{Dimostrazione}[subsection]
\newtheorem{Osservazione}{Osservazione}[subsection]
\newtheorem{Nota}{Nota}[subsection]

\title{RSO: Sistemi Operativi}
\author{spitfire}
\date{A.A. 2023-2024}
\begin{document}
\begin{figure}
    \centering
    \includegraphics[width=0.35\textwidth]{Images/Logo scienze bicocca.png}
\end{figure}

\vspace{10cm}
\date{A.A. 2023-2024}


\maketitle

\newpage

\tableofcontents
\newpage

\section{Struttura e servizi}
Cosa sappiamo sui sistemi operativi? Sappiamo che, per esempio, i principali sono
\textbf{linux, Windows e MacOS}; che il sistema operativo è il 
\textbf{primo programma che viene eseguito dopo il boot}. Di solito un sistema operativo
fornisce un \textbf{ambiente desktop a finestre e ci permette di installare nuove applicazioni}.
Ci permette inoltre di eseguire tante applicazioni \textbf{contemporaneamente}, anche più dei \textbf{core dei processori}.
Inoltre, esso \textbf{mantiene e organizza i nostri dati sotto forma di file e cartelle}.
Quindi, cos'è un \textbf{sistema operativo}? Esso è:
\begin{itemize}
    \item Un insieme di \textbf{programmi} (Software)
    \item Che gestiscono \textbf{gli elementi fisici di un computer} (Hardware)
\end{itemize}
E a \textbf{cosa serve un sistema operativo}?
\begin{itemize}
    \item Fornire una \textbf{piattaforma di sviluppo per le applicazioni}, che permette loro di \textbf{condividere e astrarre} le risorse HW.
    \item Agisce da \textbf{intermediario} tra utenti e computer, permettendo agli utenti di \textbf{controllare l'esecuzione dei programmi applicativi} e l'assegnazione delle risorse HW ad essi
    \item \textbf{Protegge le risorse degli utenti} (e dei loro programmi) dagli altri utenti (e dai loro programmi) e da eventuali \textbf{attori esterni}
\end{itemize}
Un sistema operativo è quindi in primo luogo una \textbf{piattaforma di sviluppo}, ossia un insieme di funzionalità software che i programmi applicativi possono usare.
Tali funzionalità permettono ai programmi di poter usare in maniere conveniente le risorse hardware di condividerle:
\begin{itemize}
    \item Da un lato il sistema operativo \textbf{astrae} le risorse hardware, presentando agli sviluppatori di programmi applicativi una visione delle risorse hardware più facile da usare e più potente rispetto alle risorse hardware "native".
    \item Dall'altro, il sistema operativo \textbf{condivide} le risorse hardware tra molti programmi contemporaneamente in esecuzione, suddividendole tra i programmi in maniera equa ed efficiente e controllando che questi le usino correttamente.
\end{itemize}
\subsection{Componenti di un sistema di elaborazione}
Le componenti di un sistemi di elaborazione sono:
\begin{itemize}
    \item \textbf{Utenti}: Persone, macchine, altri computer, ecc...
    \item \textbf{Programmi applicativi}: Risolvono i problemi di calcolo degli utenti
    \item \textbf{Sistema operativo}: Coordina e controlla l'uso delle risorse hardware
    \item \textbf{Hardware}: Risorse di calcolo (CPU, periferiche, memoria di massa, ...)
\end{itemize}
\begin{center}
    \includegraphics[width = 0.50\textwidth]{Images/1.PNG}
\end{center}
\subsection{Requisiti per i sistemi operativi}
Oggigiorno i computer sono ovunque: vi sono molteplici tipologie di computer utilizzati in scenari
applicativi molto diversi. In quasi tutti i tipi di computer si tende ad installare un sistema operativo allo scopo
di gestire l'hardware e semplificare la programmazione. Ma ogni scenario applicativo in cui viene usato un computer
richiede che il sistema operativo che vi viene installato abbia caratteristiche ben determinate. Che cosa si richiede quindi
ad un sistema operativo per supportare uno determinato scenario applicativo?
Vediamo qualche scenario:
\begin{itemize}
    \item \textbf{Server e Mainframe}: massimizzare le performance, rendere equa la condivisione delle risorse tra molti utenti
    \item \textbf{Laptop, PC e tablet}: massimizzare la facilità d'uso e la produttività della singola persona che lo usa
    \item \textbf{Dispositivi mobili}: Ottimizzare i consumi energetici e la connettività
    \item \textbf{Sistemi embedded}: funzionare senza, o con minimo, intervento umano e reagire in tempo reale agli stimoli esterni (interrupt)
\end{itemize}
\subsection{La maledizione della generalità}
Nella storia (ed anche oggi) alcuni sistemi operativi sono stati utilizzati per scenari applicativi diversi.
Ad esempio, Linux è usato oggi nei server, nei computer desktop e nei dispositivi mobili (come parte di Android).
La \textbf{maledizione della generalità} afferma che, se un sistema operativo deve supportare un insieme di scenari applicativi troppo ampio,
non sarà in grado di supportarne nessuno particolarmente bene. Esempio di questo si è visto con \textbf{OS/360}, il primo sistema operativo che doveva supportare
una famiglia di computer diversi (la linea 360 IBM).
\subsection{Struttura dei sistemi operativi}
Non c'è una definizione universalmente accettata di quali programmi fanno pare di un sistema operativo. In generale però un sistema operativo almeno comprende:
\begin{itemize}
    \item \textbf{Kernel}: Il "programma sempre presente" che si "impadronisce" dell'HW, lo gestisce, ed offre ai programmi i servizi per poterlo usare in maniera condivisa ed astratta
    \item \textbf{Middleware}: servizi di alto livello che astraggono ulteriormente i servizi del kernel e semplificano la programmazione di applicazioni (API, framework per grafica e per suono,...)
    \item \textbf{Programmi di sistema}: Non sempre in esecuzione, offrono ulteriori funzionalità di supporto e di interazione utente con il sistema (gestione di processi e jobs, UI, ...)
\end{itemize}
Alcuni sistemi operativi forniscono "out-of-the-box" anche dei \textbf{programmi applicativi} (editor, fogli di calcolo,...) ma non li considereremo come parti del sistema operativo.
Data questa lista di componenti, possiamo rivisitare le \textbf{componenti di un sistema di elaborazione}:
\begin{center}
    \includegraphics[width = 0.55\textwidth]{Images/2.PNG}
\end{center}
Che visti in dettaglio diventano:
\begin{center}
    \includegraphics[width = 0.63\textwidth]{Images/3.PNG}
\end{center}
\subsection{Servizi offerti da un sistema operativo}
I principali servizi che un sistema operativo offre sono:
\begin{itemize}
    \item \textbf{Controllo processi}: questi servizi permettono di caricare in memoria un programma, eseguirlo, identificare la sua terminazione e registrarne la condizione di terminazione (normale o erronea)
    \item \textbf{Gestione dei file}: questi servizi permettono di leggere, scrivere e manipolare files e directories
    \item \textbf{Gestione dispositivi}: questi servizi permettono ai programmi di effettuare operazioni di input/output, ad esempio leggere da/scrivere su un terminale
    \item \textbf{Comunicazione interprocesso}: i programmi in esecuzione possono collaborare tra di loro scambiandosi informazioni: questi servizi permettono ai programmi in esecuzione di comunicare
    \item \textbf{Protezione e sicurezza}: permette ai proprietari delle informazioni in un sistema multiutente o in rete di controllarne l'uso da parte di altri utenti e di difendere il sistema dagli accessi illegali
    \item \textbf{Allocazione delle risorse}: alloca le risorse hardware (CPU, memoria, dispositivi di I/O) ai programmi in esecuzione in maniera equa ed efficiente
    \item \textbf{Rilevamento errori}: gli errori possono avvenire nell'hardware o nel software  (es. divisione per 0); quando avvengono il sistema operativo deve intraprendere opportune azioni (recupero, terminazione del programma o segnalazione della condizione di errore al programma)
    \item \textbf{Logging}: mantiene traccia di quali programmi usano quali risorse, allo scopo di contabilizzarle
\end{itemize}
\subsection{Chiamate di sistema e Application Programming Interfaces}
\begin{center}
    \includegraphics[width = 0.50\textwidth]{Images/4.PNG}
\end{center}
Il kernel offre i propri servizi ai programmi come \textbf{chiamate di sistema} (syscalls), ossia funzioni invocabili in un determinato linguaggio di programmazione (C, C++, ...).
I programmi però non utilizzano direttamente le chiamate di sistema, ma delle librerie di middleware dette \textbf{Application Programming Interface} (API) implementate invocando le chiamate di sistema.
Spesso le API sono fortemente legate con le librerie standard del linguaggio di implementazione (es. libc se le API sono implementate in C) al punto che anche queste diventano parte implicita dell'API.
Bisogna ricordare che:
\begin{itemize}
    \item Le API sono \textbf{esposte dal middleware}, mentre le chiamate di sistema \textbf{dal kernel}
    \item Le API usano le chiamate di sistema nella loro implementazione
    \item Le API sono standardizzate (es. POSIX, Win32), le chiamate di sistema no, quindi ogni kernel ha chiamate di sistema differenti
    \item Le API sono stabili, le chiamate di sistema possono variare al variare della versione del sistema operativo
    \item Le API offrono funzionalità più ad alto livello e più semplici da usare, le chiamate di sistema offrono funzionalità più elementari e più complesse da usare
\end{itemize}
\begin{center}
    \includegraphics[width = 0.75\textwidth]{Images/5.PNG}
\end{center}
\subsection{Programmi di sistema}
La maggior parte degli utenti utilizza servizi del sistema operativo attraverso i programmi di sistema.
Questi permettono agli utenti di avere un ambiente più conveniente per l'esecuzione dei programmi, il loro sviluppo e la gestione delle risorse del sistema.
Vi sono diversi tipi di programmi di sistema:
\begin{itemize}
    \item \textbf{Interfacce utente (UI)}: permette agli utenti di interagire con il sistema stesso; può essere grafica (GUI) o a riga di comando (CLI); i sistemi mobili hanno un'interfaccia touch.
    \item \textbf{Gestione file}: creazione, modifica e cancellazione di file e directories
    \item \textbf{Modifica dei file}: editor di testo, programmi per la manipolazione del contenuto dei file (Emacs)
    \item \textbf{Visualizzazione e modifica informazioni di stato}: data, ora, memoria disponibile, processi, utenti, ... fino a informazioni complesse su prestazione, accessi al sistema e debug. Alcuni sistemi implementano un \textbf{registry}, ossia un database delle informazioni di configurazione
    \item \textbf{Caricamento ed esecuzione dei programmi}: loader assoluti e rilocabili, linker e debugger
    \item \textbf{Ambienti di supporto alla programmazione}: compilatori, assemblatori, debugger, interpreti per diversi linguaggi di programmazione
    \item \textbf{Comunicazione}: forniscono i meccanismi per creare connessione tra utenti, programmi e sistemi; permettono di inviare messaggi agli schermi di un altro utente, di navigare il web, di inviare messaggi di posta elettronica, di accedere remotamente ad un altro computer, di trasferire i file, ecc...
    \item \textbf{Servizi di background}: lanciati all'avvio, alcuni terminano, altri continuano l'esecuzione fino allo shutdown. Forniscono servizi quali verifica dello stato dei dischi, scheduling di jobs, logging, ...
\end{itemize}
\subsubsection{Intefaccia utente: l'interpete dei comandi}
\begin{center}
    \includegraphics[width = 0.75\textwidth]{Images/6.PNG}
\end{center}
L'interprete dei comandi permette agli utenti di impartire in maniera testuale delle istruzioni al sistema operativo.
In molti sistemi operativi è possibile configurare quale interprete dei comandi usare, nel qual caso è detto \textbf{shell}.
Ci sono due modi per implementare un comando:
\begin{itemize}
    \item \textbf{Built-in}: l'interprete esegue direttamente il comando (tipico dell'interprete dei comandi di Windows)
    \item \textbf{Come programma di sistema}: l'interprete manda in esecuzione un programma (tipico delle shell Unix e Unix-Like)
\end{itemize}
Spesso l'interprete riconosce \textbf{un vero e proprio linguaggio di programmazione} (es. Bash).
\subsubsection{Interfaccia utente: le interfacce grafiche}
\begin{center}
    \includegraphics[width = 0.85\textwidth]{Images/7.png}
\end{center}
Le interfacce grafiche(GUI) sono di solito basate sulla metafora della scrivania, delle icone e delle cartelle (corrispondenti alle directory).
Nate dalla ricerca presso lo Xerox PARC lab negli anni 70, vennero popolarizzate dai computer Apple Macintosh negli anni 80. Su Linux le più popolari sono KDE e Gnome.
\newpage
\subsubsection{Intefaccia utente: Le interfacce touch-screen}
\begin{center}
    \includegraphics[width = 0.30\textwidth]{Images/8.PNG}
\end{center}
I dispositivi mobili richiedono interfacce di nuovo tipo. Esse non prevedono nessun dispositivo di puntamento (mouse); sostituendolo con l'uso dei gesti (gestures).
Inoltre esse possono offrire servizi come tastiere virtuali e comandi vocali.
\subsection{L'implementazione dei programmi di sistema}
\begin{center}
    \includegraphics[width = 0.55\textwidth]{Images/9.PNG}
\end{center}
I programmi di sistema sono implementati utilizzando le API, esattamente come i programmi applicativi.
Consideriamo ad esempio il comando \textit{cp} delle shell dei sistemi operativi Unix-like; la sua sintassi è:
\begin{center}
    \textit{cp in.txt out.txt}
\end{center}
Esso copia il contenuto del file \textit{in.txt} in un file \textit{out.txt}. Se il file \textit{out.txt} esiste, il contenuto precedente viene cancellato, altrimenti \textit{out.txt} viene creato.
L'immagine sopra rappresenta una possibile struttura del codice; le invocazioni delle API sono riportate in grassetto.
\textit{cp} è implementato come programma di sistema.
\section{Processi e thread: i servizi}
Un sistema operativo esegue un certo numero di programmi sullo stesso sistema di elaborazione.
Il numero di programmi da eseguire può essere arbitrariamente elevato, di solito è infatti molto maggiore del numero di CPU del sistema.
A tale scopo, il sistema operativo realizza e mette a disposizione un'astrazione detta \textbf{processo}. Un processo è quindi un'entità attiva astratta definita dal sistema operativo allo scopo di eseguire un programma.
Per il momento, assumiamo che l'esecuzione di un processo sia sequenziale, tuttavia \textbf{rilasseremo presto questa assunzione}.
\subsection{Programmi e processi}
È fondamentale notare la differenza tra programma e processo!
\begin{itemize}
    \item Un programma è un'entità passiva (un insieme di istruzioni, tipicamente contenuto in un file sorgente o eseguibile)
    \item Un processo è un'entità attiva (è un \textbf{esecutore di un programma} o un \textbf{programma in esecuzione})
\end{itemize}
Uno stesso programma può dare origine a \textbf{diversi processi}:
\begin{itemize}
    \item Diversi utenti eseguono lo stesso programma
    \item Uno stesso programma viene eseguito più volte, anche contemporaneamente, dallo stesso utente
\end{itemize}
\subsection{Struttura di un processo}
Un processo è composto da diverse parti:
\begin{itemize}
    \item Lo stato dei registri del processore che esegue il programma, incluso il PC
    \item Lo stato della \textbf{immagine} del processo, ossia della regione di memoria centrale usata dal programma
    \item Le risorse del sistema operativo in uso al programma (files, locks, ...)
    \item Più diverse informazioni sullo stato del processo per il sistema operativo
\end{itemize}
Notare che processi distinti hanno immagini distinte! Due processi operano su zone di memoria centrale separate!
Le risorse del sistema operativo invece possono essere condivise tra processi (a seconda del tipo di risorsa)
\subsubsection{L'immagine di un processo}
L'intervallo di indirizzi di memoria in cui è contenuta l'immagine di un processo è anche detto \textbf{spazio di indirizzamento} (\textbf{address space}) del processo.
L'immagine di un processo di norma contiene:
\begin{itemize}
    \item \textbf{Text section}: contiene il codice macchina del programma
    \item \textbf{Data section}: contiene le variabili globali
    \item \textbf{Heap}: contiene la memoria allocata dinamicamente durante l'esecuzione
    \item \textbf{Stack delle chiamate}: contiene parametri, variabili locali e indirizzo di ritorno delle varie procedure che vengono invocate durante l'esecuzione del programma
\end{itemize}
\begin{center}
    \includegraphics[width = 0.35\textwidth]{Images/10.PNG}
\end{center}
Text e data section hanno dimensioni costanti per tutta la vita del processo; mentre stack e heap invece crescono e decrescono durante la vita del processo.
\subsection{Operazioni sui processi}
I sistemi operativi di solito forniscono delle chiamate di sistema con le quali un processo può creare, terminare e manipolare altri processi.
Dal momento che solo un processo può creare un altro processo, all'avvio il sistema operativo crea dei processi \textbf{primordiali} dai quali tutti i processi utente e di sistema vengono progressivamente creati.
\subsubsection{Creazione di processi}
Di solito nei sistemi operativi i processi sono organizzati in maniera \textbf{gerarchica}:
Un processo \textbf{padre} può creare altri processi \textbf{figli} che a loro volta potranno essere i padri di nuovi processi.
Ciò va a creare un \textbf{albero di processi}
\begin{center}
    \includegraphics[width = 0.74\textwidth]{Images/11.PNG}
\end{center}
La relazione padre/figlio è di norma importante per le politiche di condivisione delle risorse e di coordinazione tra processi.
Vi sono diverse \textbf{politiche di condivisione di risorse}:
\begin{itemize}
    \item Padre e figlio condividono \textbf{tutte le risorse}...
    \item ...o un \textbf{opportuno sottoinsieme}...
    \item ...o \textbf{nessuna risorsa}
\end{itemize}
Quando un processo padre crea un processo figlio, esso può adottare diverse \textbf{politiche di creazione di spazio di indirizzi}:
\begin{itemize}
    \item Il figlio è un \textbf{duplicato} del padre (stessa memoria e programma1)...
    \item oppure no, e bisogna \textbf{specificare quale programma deve eseguire il figlio}
\end{itemize}
I processi padri e i loro figli possono inoltre \textbf{coordinarsi fra loro} seguendo delle \textbf{politiche di coordinazione padre/figli}:
\begin{itemize}
    \item Il padre è \textbf{sospeso} finché i figli non terminano...
    \item oppure eseguono in maniera \textbf{concorrente}
\end{itemize}
\subsubsection{Terminazione di processi}
I processi di regola richiedono esplicitamente la propria terminazione al sistema operativo. 
Un processo padre può attendere o meno la terminazione di un figlio oppure la \textbf{può forzare} per una serie di ragioni:
\begin{itemize}
    \item Il figlio sta usando \textbf{risorse in eccesso} (tempo, memoria, ...)
    \item Le funzionalità del figlio \textbf{non sono più richieste} (in questo caso, tuttavia, è meglio terminarlo in maniera ordinata tramite IPC)
    \item Il padre \textbf{termina prima del figlio} (in alcuni S.O.)
\end{itemize}
Riguardo all'ultimo punto, alcuni sistemi operativi \textbf{non permettono che i processi figli esistano se il loro processo padre è terminato}:
\begin{itemize}
    \item \textbf{Terminazione a cascata}: anche i nipoti, pronipoti, ecc... devono essere terminati
    \item La terminazione viene iniziata dal \textbf{sistema operativo}
\end{itemize}
\subsection{API POSIX per le operazioni sui processi}
\textbf{POSIX} (Portable Operating System Interface for Unix) è una famiglia di standard specificata dalla \textbf{IEEE} per mantenere la compatibilità del software tra diversi sistemi operativi,
in particolare tra le varianti di Unix (Linux e MacOS per esempio). In particolare definisce l'API disponibile (come la libreria \textbf{C POSIX} per il linguaggio C) e l'interfaccia a linea di comando
utilizzabile per shell (come \textbf{bash} e \textbf{dash}) e altri comandi fondamentali.
Un sistema operativo che segue gli standard POSIX si dice \textbf{POSIX-Compliant}.
Per operare sui processi, POSIX definisce le seguenti API:
\begin{itemize}
    \item \textbf{fork()}: Crea un nuovo processo figlio; il figlio è un duplicato del padre ed esegue concorrentemente ad esso; ritorna al padre un \textbf{numero identificatore} (PID) del processo figlio e al figlio il PID 0.
    \item \textbf{exec()}: Sostituisce il programma in esecuzione da un processo con un altro programma, che viene \textbf{eseguito dall'inizio}; viene tipicamente usato dopo una fork() dal figlio per iniziare ad eseguire un programma diverso da quello del padre.
    exec() tuttavia definisce un intera \textbf{famiglia di funzioni} in POSIX, ognuna distinta da dei \textbf{suffissi} di cui ogni lettera ha un significato particolare:
    \begin{itemize}
        \item \textbf{e}: Un \textbf{array di puntatori a variabili d'ambiente} è passato esplicitamente alla nuova immagine del processo
        \item \textbf{l}: Gli argomenti passati \textbf{da linea di comando} sono passati individualmente (come lista) alla funzione
        \item \textbf{p}: Utilizza la variabile d'ambiente \textbf{PATH} per trovare il file nominato nell'argomento "file" per eseguirlo
        \item \textbf{v}: Gli argomenti passati \textbf{da linea di comando} sono passati come un array di puntatori
    \end{itemize}
    Tendenzialmente, gli argomenti di una exec() sono:
    \begin{itemize}
        \item Il \textbf{path} del programma da eseguire oppure il \textbf{file descriptor} (fd) del file da eseguire
        \item Gli \textbf{argomenti} da passare all'entry point del programma da eseguire
    \end{itemize}
    \item \textbf{wait()}: viene chiamata dal padre per attendere la fine dell'esecuzione di un figlio; ritorna:
    \begin{itemize}
        \item il \textbf{PID} del figlio che è terminato
        \item Il codice di ritorno del figlio (passato come parametro dal figlio in \textbf{exit()})
    \end{itemize}
    \item \textbf{exit()}: fa terminare il processo che la invoca:
    \begin{itemize}
        \item Accetta come parametro un codice di ritorno numerico
        \item Il sistema operativo elimina il processo e recupera le sue risorse
        \item Quindi restituisce al processo padre il codice di ritorno (se ha invocato wait(), altrimenti lo memorizza per quando lo invocherà)
        \item Viene implicitamente invocata se il processo esce dalla funzione main
    \end{itemize}
    \item \textbf{abort()}: fa terminare forzatamente un processo figlio
\end{itemize}
Tendenzialmente la tipica sequenza di fork-exec è rappresentabile come segue:
\begin{center}
    \includegraphics[width = 1\textwidth]{Images/12.PNG}
\end{center}
\subsection{Processi zombie e orfani}
Se un processo termina ma il suo padre non lo sta aspettando (cioè non ha invocato wait()), il processo è detto essere \textbf{zombie}:
le sue risorse non possono essere completamente deallocate (il padre potrebbe prima o poi invocare wait()).
Se un processo padre termina prima di un suo figlio e \textbf{non vi è terminazione a cascata} allora i suoi processi figli si dicono \textbf{orfani}.
\subsection{Comunicazione interprocesso}
Più processi possono essere indipendenti o cooperare. Un processo coopera con uno o più altri processi se il suo comportamento "influenza" o "è influenzato da" il comportamento di questi ultimi.
Vi sono più motivi per il quale si vogliono avere processi cooperanti:
\begin{itemize}
    \item \textbf{Condivisione} di informazioni
    \item \textbf{Accelerazione} di computazioni
    \item \textbf{Modularità} e \textbf{isolamento} (come in Chrome)
\end{itemize}
Per permettere ai processi di cooperare il sistema operativo deve mettere a disposizione primitive di \textbf{comunicazione interprocesso} (IPC).
Vi sono due tipi di primitive:
\begin{itemize}
    \item \textbf{Memoria condivisa}
    \item \textbf{Message passing}
\end{itemize}
\subsubsection{Modelli di IPC}
\begin{center}
    \includegraphics[width = 0.65\textwidth]{Images/13.PNG}
\end{center}
\subsubsection{IPC tramite memoria condivisa}
Nella IPC tramite memoria condivisa viene stabilita una zona di memoria condivisa tra i processi che intendono comunicare.
La comunicazione è \textbf{controllata dai processi che comunicano} e non dal sistema operativo.
Un problema importante è permette ai processi che comunicano tramite memoria condivisa di \textbf{sincronizzarsi} (un processo non deve leggere la memoria condivisa mentre l'altro sta scrivendo).
Allo scopo, i sistemi operativi mettono a disposizione ulteriori primitive per la \textbf{sincronizzazione}.
\subsubsection{IPC tramite message passing}
Nell'IPC tramite message passing, si permette ai processi \textbf{sia di comunicare che di sincronizzarsi}.
I processi comunicano tra di loro \textbf{senza condividere memoria} attraverso la mediazione del sistema operativo.
Questo mette a disposizione:
\begin{itemize}
    \item Un'operazione \textbf{send(message)} con la quale un processo può inviare un messaggio ad un altro processo
    \item Un'operazione \textbf{receive(message)} con la quale un processo può ricevere un messaggio o mettersi in attesa fino a quando non ne riceve uno.
\end{itemize}
Per comunicare fra loro, due processi devono:
\begin{itemize}
    \item Stabilire un \textbf{link di comunicazione} tra di loro
    \item Scambiarsi \textbf{messaggi} usando \textit{send} e \textit{receive}
\end{itemize}
\subsubsection{Pipe}
Le \textbf{pipe} sono canali di comunicazione tra i processi e sono una forma di IPC tramite \textbf{message passing}.
Ve ne sono di vario tipo:
\begin{itemize}
    \item \textbf{Unidirezionale}
    \item \textbf{Bidirezionale}
    \begin{itemize}
        \item \textbf{Half-Duplex}
        \item \textbf{Full-Duplex}
    \end{itemize}
    \item \textbf{Relazione} tra i processi comunicanti (sono padre-figlio oppure no)
    \item Usabili o meno in \textbf{rete}
\end{itemize}
Convenzionalmente, le pipe sono:
\begin{itemize}
    \item \textbf{Unidirezionali}
    \item Non accessibili al di fuori del processo creatore; sono quindi di solito \textbf{condivise} con un processo figlio attraverso una \textbf{fork()}
    \item In Windows sono chiamate \textbf{pipe anonime}
\end{itemize}
Vi sono anche le \textbf{named pipes}:
\begin{itemize}
    \item \textbf{Bidirezionali}
    \item Esistono anche \textbf{dopo la terminazione} del processo che le ha create 
    \item Non richiedono una relazione padre-figlio tra i processi che la usano
\end{itemize}
In \textbf{Unix}, le named pipes sono:
\begin{itemize}
    \item Half-duplex
    \item Sono accessibili solo sulla stessa macchina
    \item Trasportano solo dati byte-oriented
\end{itemize}
In \textbf{Windows} invece, le named pipes sono:
\begin{itemize}
    \item Full-duplex
    \item Sono accessibili anche da macchine diverse
    \item Trasportano anche dati message-oriented
\end{itemize}
\subsubsection{Notifiche con callback}
In alcuni sistemi operativi (es. API POSIX e Win32) un processo può \textbf{notificare} un altro processo in maniera da causare \textbf{l'esecuzione di un blocco di codice} ("callback"), similmente a 
ciò che avviene durante un \textbf{interrupt}.
Nei sistemi Unix-like (POSIX, Linux) tale notifiche vengono dette \textbf{segnali} ed interrompono in maniera \textbf{asincrona} la computazione del processo corrente,
causando un \textbf{salto brusco alla callback di gestione}, al termine della quale la computazione \textbf{ritorna al punto di interruzione}.
Nelle API Win32 esiste un meccanismo simile, detto \textbf{Asynchronous Procedure Call} (APC), che però richiede che il ricevente si metta \textbf{esplicitamente in uno stato di attesa} e che esponga un servizio che il mittente possa invocare.
\subsection{API POSIX per l'IPC}
\subsubsection{Memoria condivisa in POSIX}
Un processo crea o apre un segmento di memoria condivisa con la funzione \textit{smh\_open}:
\begin{center}
    \textit{int shm\_fd = shm\_open(const char *name, int oflag, mode\_t mode);}
\end{center}
dove:
\begin{itemize}
    \item Il parametro \textbf{oflag} può avere i seguenti valori:
    \begin{itemize}
        \item \textbf{O\_RDONLY}: Apertura in sola lettura
        \item \textbf{O\_RDWR}: Apertura per lettura o scrittura
        \item \textbf{O\_CREAT}: Crea lo spazio di memoria condivisa
        \item \textbf{O\_EXCL}: Se \textbf{O\_EXCL} e \textbf{O\_CREAT} sono settate; allora \textit{shm\_open} fallisce se l'oggetto di memoria condivisa con quel nome esiste già. Se invece Se \textbf{O\_EXCL} è settata ma non Se \textbf{O\_CREAT} allora il risultato è \textbf{indefinito}
        \item \textbf{O\_TRUNC}: Se l'oggetto esiste ed è stato aperto con successo tramite \textbf{O\_RDWR}, allora l'oggetto sarà troncato a lunghezza 0.
        \item Si possono utilizzare \textbf{O\_RDONLY} e \textbf{O\_RDWR} in combinazione con le altre flag, ma non insieme.
    \end{itemize}
    \item Il parametro \textit{mode} indica invece la \textbf{modalità di accesso} con cui si sta accedendo all'oggetto di memoria condivisa.
    La modalità è quindi con quali \textbf{permessi} si accede all'oggetto ed essi sono rappresentati da una \textbf{maschera di bit} in base 8 (da 0 a 7).
    In UNIX, i permessi sono rappresentati tramite \textbf{3 triadi}, che rappresentano rispettivamente quali permessi sul file hanno \textbf{l'utente, i membri del gruppo e gli utenti "esterni al gruppo"}.
    Diamo una tabella di quelli più comuni:
    \begin{center}
        \includegraphics[width = 0.90\textwidth]{Images/14.PNG}
    \end{center}
\end{itemize}
Un esempio di chiamata è:
\begin{center}
    \textit{int shm\_fd = shm\_open(name, O\_CREAT | O\_RWDR, 0666)}
\end{center}
Quando si crea un nuovo segmento, è necessario \textbf{impostarne la dimensione}; ciò viene fatto tramite la funzione
\textbf{ftruncate} che ha firma:
\begin{center}
    \textit{int ftruncate(int fildes, off\_t length)}
\end{center}
Dove \textbf{fildes}, nel nostro caso, è il \textbf{file descriptor} del segmento di memoria e \textbf{length} sarà la dimensione
che gli vogliamo dare (in byte).
Infine, la funzione \textbf{mmap} mappa la memoria condivisa nello spazio:
\begin{center}
    \textit{void* mmap(void* addr, size\_t len, int prot, int flags, int flides, off\_t off);}
\end{center}
dove:
\begin{itemize}
    \item Il parametro \textbf{addr} è l'indirizzo di partenza dello spazio di memoria condivisa. Questo parametro viene in verità usato come
    \textbf{SUGGERIMENTO} da parte del kernel del sistema operativo; ciò accade perché lo spazio di indirizzi indicato da addr e len \textbf{potrebbe essere già allocato}.
    \item Il parametro \textbf{length} specifica la lunghezza (in byte) dello spazio di memoria allocato
    \item Il paramtero \textbf{prot} indica quali operazioni sono permesse sulla regione di memoria; esso può assumere:
    \begin{itemize}
        \item \textbf{PROT\_READ}: I dati possono essere letti
        \item \textbf{PROT\_WRITE}: I dati possono essere scritti
        \item \textbf{PROT\_EXEC}: I dati possono essere eseguiti
        \item \textbf{PROT\_NONE}: I dati non possono essere acceduti
    \end{itemize}
    \item Il paramtero \textbf{flag} fornisce ulteriori informazioni riguardo la gestione dei dati mappati sullo spazio di memoria. Esso può assumere:
    \begin{itemize}
        \item \textbf{MAP\_SHARED}: I cambiamenti sono condivisi
        \item \textbf{MAP\_PRIVATE}: I cambiamenti sono privati
        \item \textbf{MAP\_FIXED}: Quando questa flag è impostata, la regione di memoria allocata \textbf{parte esattamente da addr} al posto di usarlo come un suggerimento.
    \end{itemize}
    \item Il parametro \textbf{filedes} indica il file (o l'oggetto) che rappresenta lo spazio di memoria condivisa
    \item Il parametro \textbf{off} indica l'offset nel file da dove inizia lo spazio di memoria condivisa
\end{itemize}
Un'esempio di chiamata può essere:
\begin{center}
    \textit{void* shm\_ptr = mmap(0, 4096, PROT\_WRITE, MAP\_SHARED, shm\_fd, 0)}
\end{center}
Da questo momento si può quindi usare il puntatore shm\_ptr ritornato da mmap per leggere/scrivere la memoria condivisa.
\subsubsection{Pipe anonime in POSIX}
Le pipe anonime in POSIX vengono create con la funzione \textit{pipe}, che ritorna due descrittori, uno per punto di lettura e uno per il punto di scrittura.
Ipotizziamo quindi di avere un array \textit{int pd\_fd[2]}; la funzione \textit{pipe} ha la seguente firma:
\begin{center}
    \textit{pipe(int fildes[2])}
\end{center}
Con \textit{fildes[2]} l'array in cui verranno scritti i descrittori di lettura e scrittura (lettura nella cella 0 e scrittura nella cella 1). La funzione ritorna 0 se ha avuto successo, -1 altrimenti; in questo caso
verrà impostata la flag \textit{ERRNO} per indicare l'errore e i descrittori NON verranno allocati all'interno di \textit{fildes[2]}. Un esempio di chiamata di \textit{pipe} è:
\begin{center}
    \textit{int res = pipe(p\_fd)}
\end{center}
Le funzioni \textit{read} e \textit{write} permettono rispettivamente di leggere e scrivere: \newline
La funzione write ha la seguente firma:
\begin{center}
    \textit{ssize\_t write (int fildes, const void* buf, size\_t nbyte)}
\end{center}
Essa cercherà di scrivere \textit{nbyte} dal buffer puntato da \textit{buf} al file associato al file descriptor \textit{fildes}.
La funzione ritorna il numero di byte effettivamente scritto, altrimenti -1.
Una scrittura sulla pipe anonima d'esempio può essere quindi:
\begin{center}
    \textit{ssize\_t n\_wr = write(p\_fd[1], "Hello World!", 14);}
\end{center}
La funzione \textit{read} ha la seguente firma:
\begin{center}
    \textit{ssize\_t read(int fildes, void* buf, size\_t nbyte);}
\end{center}
La funzione cercherà di leggere \textit{nbyte} dal file associato al file descriptor \textit{fildes} e di porre ciò che ha letto
nel buffer puntato da \textit{buf}. La funzione restituirà il numero di byte letti se ha avuto successo, -1 altrimenti.
Un esempio di lettura dalla pipe anonima d'esempio può essere quindi:
\begin{center}
    \textit{char buffer[256];} \\
    \textit{ssize\_t n\_rd = read(p\_fd[0], buffer, sizeof(buffer) - 1);}
\end{center}
\subsubsection{Named Pipes in POSIX}
Le named pipes vengono anche chiamate \textbf{FIFO} nei sistemi POSIX. Per creare una FIFO, si utilizza l'API \textit{mkfifo}, che ha la seguente firma:
\begin{center}
    \textit{int mkfifo(const char *path, mode\_t mode);}
\end{center}
La funzione andrà a creare un nuovo file speciale FIFO con nome dato dal percorso puntato da \textit{path}.
I bit dei permessi del file saranno impostati come specificato in \textit{mode}.
La funzione ritorna 0 se la creazione del file avviene con successo, -1 altrimenti.
Un esempio di chiamata può quindi essere:
\begin{center}
    \textit{int res = mkfifo("/home/pietro/myfifo", 0640);}
\end{center}
La FIFO quindi potrà utilizzare come un normale file; in particolare possiamo aprirla tramite l'API \textit{open}:
\begin{center}
    \textit{int open(const char *path, int oflag, ...);}
\end{center}
La funzione quindi aprirà il file specificato in \textit{path}.
Il parametro \textit{flag} deve obbligatoriamente assumere uno dei seguenti valori:
\begin{itemize}
    \item \textbf{O\_RDONLY}: il file viene aperto in modalità di sola lettura
    \item \textbf{O\_WRONLY}: il file viene aperto in modalità di sola scrittura
    \item \textbf{O\_RDWR}: Il fine viene aperto ed è possibile effettuare su di esso sia le operazioni di lettura che di scrittura
\end{itemize}
Inoltre è possibile specificare, in OR bitwise (|) con uno dei valori di \textit{flag} sopra (cioè viene fatto l'or bit a bit dei valori), le seguenti flag:
\begin{itemize}
    \item \textbf{O\_APPEND}: Il file viene aperto in "append mode", cioè ogni scrittura viene fatta alla fine del file
    \item \textbf{O\_CLOEXEC}: Viene impostata, per questo file, la flag \textbf{FD\_CLOEXEC}, cioè il file verrà chiuso se un processo che lo gestisce usa una delle funzioni della famiglia \textit{exec} viene eseguita sul file
    \item \textbf{O\_CLOFORK}: Viene impostata, per questo file, la flag \textbf{FD\_CLOFORK}, cioè il file verrà chiuso se un processo che lo gestisce effettua una \textit{fork()}
    \item \textbf{O\_CREAT}: Se il \textbf{path} non esiste, lo crea come un file normale. (n.d.a Si faccia riferimento a \textit{man} o alla documentazione POSIX per una spiegazione più dettagliata)
    \item \textbf{O\_DIRECTORY}: Se \textit{path} risolve a un file che NON è una directory, questa flag porta la funzione a fallire
    \item \textbf{O\_EXCL}: Se \textbf{O\_CREAT} e \textbf{O\_EXCL} sono entrambe impostate, la funzione fallirà se il file già esiste. Se invece solo questa flag è impostata, il risultato è \textbf{indefinito}
    \item \textbf{O\_TRUNC}: Se il file esiste ed è un file normale e il file è stato aperto con successo in modalità "sola scrittura" (flag ha valore \textit{O\_WRONLY}) oppure in è aperto in "modalità lettura e scrittura" (flag ha valore \textit{O\_RDWR}), allora tutti i contenuti del file verranno troncati (cioè cancellati) e la sua lunghezza verrà impostata a 0.
\end{itemize}
Quindi, un esempio di apertura di una FIFO può essere il seguente:
\begin{center}
    \textit{int fd = open("/home/pietro/myfifo", O\_RDONLY);}
\end{center}
Poiché una FIFO può essere utilizzata come un file normale, possiamo anche usare le API \textit{read} e \textit{write} viste prima per leggere e scrivere su di essa:
\begin{center}
    \textit{char buffer[256];} \\
    \textit{ssize\_t n\_rd = read(fd, buffer, sizeof(buffer) - 1);}
\end{center}
Al termine dell'utilizzo, dobbiamo ricordarci di \textbf{chiudere la FIFO}; per farlo usiamo l'API \textbf{close}:
\begin{center}
    \textit{int close(int fildes)}
\end{center}
La funzione prende in input il file descriptor e lo chiude (cioè chiude il file).
La funzione ritorna 0 se ha successo, -1 se invece fallisce. Per chiudere la FIFO che abbiamo presentato fino a qui come esempio,
possiamo quindi procedere in questo modo:
\begin{center}
    \textit{close(fd);}
\end{center}
Per invece \textbf{eliminare} una FIFO, possiamo usare l'API \textbf{unlink}:
\begin{center}
    \textit{int unlink(const char* path)}
\end{center}
l'API, in generale, si comporta in maniera differente in base a \textbf{cosa viene specificato come valore di path}:
\begin{itemize}
    \item Se quel nome era \textbf{l'ultimo collegamento ad un file e nessun processo ha quel file aperto}, il file viene \textbf{eliminato} e lo spazio che stava usando viene reso disponibile per il riuso.
    Se invece il file è ancora in uso da parte di un processo, esso rimarrà in memoria fino a quando \textbf{l'ultimo file descriptor che lo referenzia non viene chiuso}.
    \item Se il nome specificato è un \textbf{link simbolico} (un collegamento), esso viene rimosso
    \item Se il nome si riferisce ad una \textbf{Socket}, una \textbf{FIFO} o ad un \textbf{dispositivo}, allora il nome viene rimosso, ma i processi che lo stavano usando \textbf{possono continuare a farlo}
\end{itemize} 
La funzione ritorna 0 se ha successo, altrimenti -1. Per eliminare quindi una FIFO usando \textit{unlink}, possiamo procedere nel seguente modo:
\begin{center}
    \textit{unlink("/home/pietro/myfifo");}
\end{center}
\subsubsection{Segnali in POSIX}
Possiamo inviare un segnale ad un processo utilizzando l'API \textit{kill}:
\begin{center}
    \textit{int kill(pid\_t pid, int sig)}
\end{center}
Dove \textit{pid} è l'ID del processo e \textit{sig} è il segnale che si vuole inviare.
I segnali che si possono inviare sono definiti nella libreria \textbf{signal.h}.
Un esempio di utilizzo può essere il seguente:
\begin{center}
    \textit{int ok = kill(1000, SIGERM);}
\end{center}
Per registrare una callback per un determinato segnale, possiamo usare l'API \textit{sigaction}:
\begin{center}
    \textit{int sigaction(int sig, const struct sigaction *restrict act, struct sigaction *restrict oact);}
\end{center}
In particolare, la funzione permette al processo chiamate di esaminare e/o specificare l'azione che deve essere associata ad un certo segnale.
Il parametro \textit{sig} specifica il segnale, i cui valori accettabili sono definiti in \textbf{signal.h}. La \textbf{struttura} sigaction, usata per
descrivere l'azione da intraprendere, è definita anch'essa in \textbf{signal.h} ed include almeno i seguenti membri:
\begin{center}
    \includegraphics[width = 0.55\textwidth]{Images/15.PNG}
\end{center}
Abbiamo poi comportamenti diversi a seconda del valore degli argomenti \textit{act} e \textit{oact}. Per quanto
riguarda \textit{act} abbiamo:
\begin{itemize}
    \item Se il suo valore NON è un \textbf{puntatore a null}, esso punta ad una struttura che specifica l'azione da essere associata con il segnale specificato
    \item Se il suo valore È un \textbf{puntatore a null}, la gestione dei segnali \textbf{rimane invariata} (rispetto alla gestione normale del S.O.)
\end{itemize}
Per quanta riguarda \textit{oact} invece abbiamo:
\begin{itemize}
    \item Se il suo valore NON è un \textbf{puntatore a null}, l'azione precedentemente associata al segnale è immagazzinate nella locazione puntata da \textit{oact}
\end{itemize}
L'API restituirà 0 se ha avuto successo, -1 altrimenti.
Un esempio quindi di registrazione di una callback è il seguente:
\begin{center}
    \textit{struct sigaction act;} \\
    \textit{sigemptyset(\textnormal{\&}act.sa\_mask); /* non bloccare gli altri segnali */} \\
    \textit{act.sa\_flags = SA\_SIGINFO; /* callback in act.sa\_sigaction *()} \\
    \textit{act.sa\_sigaction = sigterm\_handler; /* la callback */} \\
    \textit{int ok = sigaction(SIGTERM, \textnormal{\&}act, NULL);}
\end{center}
\subsection{Multithreading}
Fino ad ora abbiamo assunto che un processo abbia un singolo flusso di esecuzione sequenziale (ossia, un singolo processore virtuale).
Se supponiamo che un processo possa avere \textbf{molti} processori virtuali, più istruzioni possono eseguire concorrentemente, e quindi il processo può avere più percorsi
(\textbf{thread}) di esecuzione concorrenti.
I thread di uno stesso processo condividono la memoria globale (data), la memoria contenente il codice (code) e le risorse ottenute dal sistema operativo (ad esempio i file aperti).
Ogni thread di uno stesso processo però deve avere \textbf{proprio stack}, altrimenti le chiamate a subroutine di un thread interferirebbero con quello di un altro thread concorrente.
\begin{center}
    \includegraphics[width = 0.85\textwidth]{Images/16.PNG}
\end{center}
Le \textbf{librerie di un thread} sono le API fornite al programmatore per creare e gestire un thread.
Le librerie più in uso sono \textbf{POSIX pthreads} e \textbf{Windows Threads}.
\subsection{POSIX pthreads}
La libreria \textbf{POSIX pthreads non sono un'implementazione}, ma una specifica (POSIX standard IEEE 1003.1c).
Esse sono comuni nei sistemi Unix e Unix-like (BSD, Linux, MacOS).
All'inizio di un processo, viene creato un singolo thread.
Per creare un nuvo thread si utilizza l'API \textit{pthread\_create}, la quale ha la seguente firma:
\begin{center}
    \textit{pthread\_create(pthread\_t *restrict thread, const pthread\_attr\_t *restrict attr, void *(*start\_routine)(void*), void* restrict arg);}
\end{center}
L'API creerà un nuovo thread, con gli attributi specificati da \textit{attr}, all'interno del processo.
Se \textit{attr} è NULL, gli attributi di default saranno usati. Se gli attributi specificati da \textit{attr} sono vengono modificati successivamente, gli attributi
del thread creato non verranno modificati. Se l'esecuzione va a buon fine, l'API immagazzinerà l'ID del thread creato nella locazione specificata da \textit{thread}.
Il parametro \textit{start\_routine} indica \textbf{la funzione che il thread andrà ad eseguire}, passandogli \textbf{\textit{arg} come suo solo parametro}. Il thread continuerà ad eseguire fino a quando la funzione che sta eseguendo
non ritorna. La funzione \textit{pthread\_create} ritornerà 0 se ha successo, altrimenti verrà ritornato un numero diverso da 0 per indicare l'avvenimento di un errore.
Per invece attendere la fine dell'esecuzione di un thread si utilizza l'API \textit{pthread\_join}, la quale ha la seguente firma:
\begin{center}
    \textit{int pthread\_join(pthread\_t thread, void ** valure\_ptr);}
\end{center}
L'API \textbf{sospenderà} l'esecuzione del thread chiamante fino a quando il thread obbiettivo (specificato nel parametro \textit{thread}) termina, a meno che il thread obbiettivo non sia già terminato.
Quando l'API ritorna con successo con un valore di \textit{value\_ptr} non NILL, il valore passato a \textit{pthread\_exit()} (API chiamata per cancellare un thread) dal thread terminante sarà reso disponibile
nella locazione referenziata da \textit{value\_ptr}.
L'API ritornerà 0 se la funzione ha successo, altrimenti sarà ritornato un numero diverso da 0 che indica l'errore.
Un esempio di utilizzo di queste due API può essere il seguente:
\begin{center}
    \textit{void* thread\_code(void* name) {...}} \\
    \textit{...} \\
    \textit{phtread\_id tid1, tid2;} \\
    \textit{int ok1 = pthread\_create(\textnormal{\&}td1, NULL, thread\_code, "thread 1);} \\
    \textit{int ok2 = pthread\_create(\textnormal{\&}td2, NULL, thread\_code, "thread 2);} \\
    \textit{...} \\
    \textit{void *ret1, *ret2;} \\
    \textit{ok1 = pthread\_join(tid1, \textnormal{\&}ret1);} \\
    \textit{ok2 = pthread\_join(tid2, \textnormal{\&}ret2);}
\end{center}
\newpage
\subsubsection{Comportamento rispetto alle chiamate di sistema fork() ed exec()}
Una \textit{fork()} dovrebbe duplicare solo il thread chiamante o tutti i thread? Alcuni sistemi operativi Unix-like hanno
\textbf{diverse \textit{fork()}}.\newline
\textit{exec()} invocata da un thread che effetto ha sugli altri thread? Di solito \textbf{termina tutti i thread del processo} precedentemente
all'esecuzione.
\subsubsection{Gestione dei segnali}
Quando un processo è single-threaded, un segnale interrompe l'unico thread del processo.
Quando vi sono più thread, quale thread riceve il segnale? Vi sono diversi soluzioni:
\begin{itemize}
    \item Il thread a cui si applica il segnale (ad es. il segnale \textit{SIGSEGV} viene inviato al thread che ha generato il segmentation fault)
    \item Ogni thread del processo
    \item Alcuni thread del processo
    \item Un thread speciale del processo deputato esclusivamente alla ricezione dei segnali
\end{itemize}
\subsubsection{Cancellazione dei thread}
L'operazione di cancellazione di un thread determina la terminazione prematura del thread.
Può essere invocata anche da un altro thread.
Vi sono due approcci per la cancellazione:
\begin{itemize}
    \item \textbf{Cancellazione asincrona}: il thread che riceve la cancellazione viene terminato immediatamente
    \item \textbf{Cancellazione differita}: un thread che supporta la cancellazione differita deve controllare periodicamente se esiste una richiesta di cancellazione pendente, e in tal caso terminare la propria esecuzione
\end{itemize}
Questi due approcci hanno i seguenti vantaggi:
\begin{itemize}
    \item \textbf{Cancellazione differita}: dal momento che un thread controlla il momento della propria cancellazione, può effettuare una terminazione ordinata
    \item \textbf{Cancellazione asincrona}: nessuna necessità di controllare periodicamente se ci sono richieste di cancellazione pendenti
\end{itemize}
Nei \textbf{POSIX pthreads} si può attivare/disattivare la cancellazione, ed avere sia cancellazione differita (default) che asincrona.
Se la cancellazione è inattiva, le richieste di cancellazione rimangono in attesa fino a quando (se) è attivata.
In caso di \textbf{cancellazione differita}, questa avviene solo quando l'esecuzione del thread raggiunge un punto di cancellazione (di solito una chiamata di sistema bloccante).
Il thread può aggiungere un punto di cancellazione controllando l'esistenza di richieste di cancellazione con la funzione \textit{pthread\_testcancel()}.
Presentiamo un esempio:
\begin{center}
    \includegraphics[width = 0.95\textwidth]{Images/17.png}
\end{center}
\subsubsection{Dati locali dei thread}
In alcuni casi è utile assegnare ad un thread dei dati locali (\textbf{thread local storage, TLS}) non condivisi con gli altri thread dello stesso processo.
La TLS è diversa dalle variabili locali (ad es. è visibile a tutte le funzioni). Essa è simile ai dati \textit{static} del linguaggio C, ma unica per ciascun thread. È utile quando il programma non ha un controllo
diretto sul momento di creazione dei thread (es. quando si usano i thread pools). In POSIX, i dati locali dei thread si possono creare utilizzando le funzioni:
\begin{itemize}
    \item \textbf{\textit{pthread\_key\_create(...)}}: crea un oggetto opaco di tipo \textit{pthread\_key\_t}, che può essere usato da tutti i thread per identificare un dato locale
    \item \textbf{\textit{pthread\_set\_specific(...)}}: permette di associare ad una \textit{pthread\_key\_t} un valore di tipo \textit{void*}
    \item \textbf{\textit{pthread\_getspecific(...)}}: permette di richiamare un oggetto \textit{pthread\_key\_t} data la chiave
\end{itemize} 
Ogni thread pul associare ad una stessa chiave il proprio distinto valore locale (e successivamente richiamarlo).

\section{Gestione della memoria: i servizi}
Perché un programma possa andare in esecuzione esso deve avere a disposizione:
\begin{itemize}
    \item Il processore, per eseguire il codice
    \item La memoria centrale, per memorizzare il codice e i dati sul quale il codice opera
\end{itemize}
Solo nei sistemi operativi più semplici un solo programma alla volta è in memoria: nei moderni sistemi operativi molti programmi sono contemporaneamente in memoria in uno stesso istante.
Secondo la terminologia precedentemente introdotta: più immagini di più processi sono presenti contemporaneamente nella memoria centrale.
Il sistema operativo deve, pertanto, allocare porzioni di memoria centrale ai diversi processi in funzione delle necessità di tali processi.
\subsection{Lo spazio di indirizzamento}
Ogni processo ha disposizione uno spazio di indirizzamento che può usare per le proprie operazioni.
\begin{center}
    \includegraphics[width = 0.35\textwidth]{Images/18.png}
\end{center}
Nei primi sistemi operativi, tale spazio di indirizzamento era il range di indirizzi di memoria centrale che veniva assegnato al processo:
ad esempio, se l'immagine di un certo processo avesse avuto dimensione 1 MB e fosse stata caricata in memoria centrale dall'indirizzo 001B:000... il suo spazio di indirizzamento sarebbe
stato 001B:0000 - 002B:0000. Questo però non permette di caricare lo stesso programma in zone diverse della memoria!
\subsection{Associazione degli indirizzi}
In presenza di molti programmi in memoria, il sistema operativo di regola carica uno stesso programma, in momenti diversi, in diverse aree di memoria (dove trova spazio).
Come fa, pertanto, un'istruzione macchina di un programma afar riferimento ad una certa locazione di memoria, se il suo indirizzo non è noto a priori, ma dipende da dove il programma viene caricato?
Una prima possibilità è che il compilatore produca codice indipendente dalla posizione, ossia \textbf{position-independent code (PIC)}, ossia codice macchina che usi solo indirizzi di memoria \textbf{relativi}, e che quindi
funzioni correttamente in qualsiasi locazione di memoria venga caricato. Una seconda possibilità è produrre codice dipendente dalla posizione e tradurre gli indirizzi dipendenti dalla posizione negli indirizzi corretti.
Questa operazione di "traduzione" è detta di \textbf{associazione (binding) degli indirizzi}.
\subsubsection{Loader e Linker}
Un programma sorgente è compilato in un file oggetto che deve poter essere caricato a partire da qualsiasi locazione di memoria fisica (\textbf{file oggetto rilocabile}).
I \textbf{linker}, o linkage editor, combinano più file oggetto (diversi file sorgente + librerie) per formare un file eseguibile. I \textbf{loader} si occupano di caricare in memoria i file eseguibili nel momento
on cui devono essere eseguiti. Inoltre, i loader (o ulteriori linker dinamici) effettuano il linking delle \textbf{librerie dinamiche}
\begin{center}
    \includegraphics[width = 0.55\textwidth]{Images/19.png}
\end{center}
\subsubsection{Librerie dinamiche}
Nei sistemi operativi odierni, non tutto il linking viene fatto a compile time: le librerie dinamiche vengono collegate a quando il programma \textbf{caricato o durante l'esecuzione del programma stesso}.
Il vantaggio delle librerie dinamiche è che queste possono essere condivise tra diversi programmi, riducendo le dimensioni dei programmi stessi e risparmiando memoria.
\subsubsection{Varianti nell'associazione degli indirizzi}
L'associazione degli indirizzi può essere fatta in tre momenti diversi:
\begin{itemize}
    \item \textbf{In compilazione}: il linker, a partire dall'indirizzo di caricamento, effettua il binding e genera \textbf{codice assoluto}
    \item \textbf{In caricamento}: il linker genera \textbf{codice rilocabile} e il loader, a partire dall'indirizzo di caricamento, effettua il binding al momento del caricamento in memoria del codice
    \item \textbf{In esecuzione}: il binding viene effettuato dall'hardware dinamicamente mentre il codice viene eseguito
\end{itemize}
Questi approcci hanno sia \textbf{vantaggi e svantaggi}:
\begin{itemize}
    \item \textbf{In compilazione}: soluzione semplice, ma se cambia l'indirizzo di caricamento il codice va ricompilato (si possono, ad esempio, avere $n$ versioni per $n$ diversi indirizzi di caricamento)
    \item \textbf{In caricamento}: permette di variare liberamente l'indirizzo di caricamento da esecuzione ad esecuzione, ma è una soluzione lenta che non permette di rilocare (spostare) l'immagine di un processo durante la sua
    esecuzione; inoltre l'eseguibile deve contenere delle opportune tabelle che indichino le istruzioni macchina da modificare
    \item \textbf{In esecuzione}: soluzione rapida che permette di rilocare l'immagine di un processo anche durante la sua esecuzione, e di proteggere la memoria centrale non assegnata ad un processo, ma richiede il supporto dell'hardware
\end{itemize}
Il binding in esecuzione è quello di fatto usato in tutti i sistemi operativi moderni; il binding in compilazione è usato per \textbf{alcuni eseguibili speciali, come il kernel}, di cui si sa a priori l'indirizzo di caricamento.
\subsection{Spazio di indirizzamento virtuale}
Nei sistemi operativi moderni, ogni processo ha uno \textbf{spazio di indirizzamento virtuale}, o \textbf{virtual address space (VAS)} indipendente dagli indirizzi fisici della memoria centrale nella quale l'immagine è caricata.
\begin{center}
    \includegraphics[width = 0.35\textwidth]{Images/20.png}
\end{center}
\begin{center}
    \includegraphics[width = 0.35\textwidth]{Images/21.png}
\end{center}
\noindent
Tale spazio di indirizzamento si estende dall'indirizzo 0 al massimo indirizzo consentito dall'architettura del processo.
Delle \textbf{tecniche di associazione degli indirizzi in esecuzione} fanno corrispondere lo spazio di indirizzamento virtuale del processo
con la regione (o le regioni) di memoria centrale che la sua immagine occupa.
Lo spazio di indirizzamento virtuale di un processo è di regola \textbf{molto più ampio della memoria centrale}.
Questo implica che buona parte dello spazio di indirizzamento virtuale \textbf{non è utilizzabile dal processo} perché non è associato a nessuna regione di memoria
centrale. Tale parte inutilizzabile è di solito compresa tra stack e heap. Stack e heap possono essere dinamicamente estesi e ridotti (automaticamente lo stack, attraverso le API lo heap).
\subsubsection{Librerie dinamiche}
Le librerie dinamiche vengono caricate nella zona tra stack e heap. Dal momento che possono essere caricate in qualsiasi posizione nel VAS, devono essere \textbf{compilate come PIC}.
\begin{center}
    \includegraphics[width = 0.35\textwidth]{Images/22.png}
\end{center}
\subsubsection{Memory mapping}
\begin{center}
    \includegraphics[width = 0.35\textwidth]{Images/23.png}
\end{center}
In generale, i sistemi operativi mettono a disposizione API per mappare una regione inutilizzabile del VAS su memoria centrale, così che diventi utilizzabile.
Esistono anche API che permettono di mappare una regione del VAS sul contenuto di un file (file mappati in memoria).
In tal modo l'accesso al file può avvenire utilizzando le istruzioni macchina per accedere alla memoria, anziché le API del filesystem.
\subsection{Le API POSIX per la gestione della memoria}
Di norma non dobbiamo usare le API per gestire stack e heap:
\begin{itemize}
    \item Lo stack è gestito automaticamente dal sistema operativo, non tramite API
    \item Lo heap è gestito di norma dal supporto runtime del linguaggio (new in C++) o dalla sua libreria (malloc in C), che \textbf{invocano API} per ridurre/espandere lo heap in funzione
    delle necessità del processo
\end{itemize}
Perché allora ci interessa sapere quali sono le API per la gestione della memoria?
\begin{itemize}
    \item Ci permettono di avere regioni di memoria con \textbf{permessi particolari} (sola lettura, eseguibili...)
    \item Ci permettono di implementare componenti quali allocatori di memoria, compilatori just-in-time,... qualora volessimo implementare il nostro nuovo linguaggio di programmazione
    \item Ci permettono di utilizzare i file mappati in memoria e la memoria condivisa
\end{itemize}
Le API Unix legacy per cambiare la dimensione del segmento dati (che nello standard POSIX comprende le regioni data e heap) sono \textit{brk} e \textit{sbrk}.
Tali API sono deprecate in favore dell'API \textit{mmap} (già presentata in questi appunti), e incompatibili con questa (ma esistono ancora in diversi OS, ad esempio Linux).
L'API mmap permette di mappare una regione ancora non utilizzata del VAS su:
\begin{itemize}
    \item \textbf{Memoria centrale}
    \item \textbf{Un file} (che viene mappato in memoria)
    \item \textbf{Memoria condivisa}
\end{itemize}
Vediamo un'ulteriore API per la gestione della memoria: \textit{msync}:
\begin{center}
    \textit{int msync(void* addr, size\_t len, int flags);}
\end{center}
L'API andrà a scrivere sul filesystem tutti i dati modificati in un file mappato in memoria 
da \textit{mmap}. Senza l'uso di questa funzione, non c'è garanzia che i cambiamenti scritti sul file
in memoria vengano mantenuti. Per essere più precisi, la parte del file che corrisponde all'area di memoria che
inizia a \textit{addr} e avente lunghezza \textit{len} viene aggiornata. L'attributo flag può avere i seguenti valori:
\begin{itemize}
    \item \textbf{MS\_ASYNC}: La scrittura delle modifiche viene effettuata in maniera asincrona
    \item \textbf{MS\_SYNC}: La scrittura delle modifiche viene effettuata in maniera sincrona
    \item \textbf{MS\_INVALIDATE}: Viene richiesto di invalidare altra mappature dello stesso file, così che possano essere aggiornate con i valori appena scritti
\end{itemize}
Queste flag sono definite in \textit{<sys/mman.h>} e possono essere combinate con un \textbf{bitwise-inclusive OR} (|).
La funzione ritorna 0 se ha successo, -1 altrimenti.
Vediamo un esempio di utilizzo di queste API:
\begin{center}
    \textit{// Mappiamo 4 KB di memoria a partire dall'indirizzo virtuale 0xa0000000} \\
    \textit{void* ptr = mmap(0xa0000000, 4096, PROT\_READ | PROT\_WRITE, MAP\_ANONYMOUS, 0, 0);} \\
    \textit{// Per mappare, a partire dall'indirizzo virtuale 0xb0000000, 8192 bytes del file /usr/foo a partire dal byte 100 scriviamo:} \\
    \textit{int fd = open("/usr/foo", O\_RDWR);} \\
    \textit{void* ptr = mmap(0xb0000000, 8192, PROT\_READ | PROT\_WRITE, MAP\_PRIVATE, fd, 100);} \\
    \textit{// Per sincronizzare le modifiche in memoria con il file, scriviamo:} \\
    \textit{int ok = msync(0xb0000000, 8192, MS\_SYNC|MS\_INVALIDATE);}
\end{center}
\section{File system: i servizi}
Il \textbf{file system} è il modo attraverso il quale il sistema operativo memorizza in linea i dati e i programmi.
Esso è costituito da:
\begin{itemize}
    \item Un insieme di file
    \item Una struttura delle directory, che organizza i file
\end{itemize}
Un \textbf{file} è una unità di memorizzazione logica, un insieme di informazioni correlate, registrare in memoria secondaria, alle quali è \textbf{stato dato un nome}.
Un file a sua volta è costituito da una \textbf{sequenza di record, righe, bit o byte}, il cui significato è definito dal creatore del file.
Un file possiede i seguenti attributi:
\begin{itemize}
    \item \textbf{Nome}: è di solito l'unica informazione in forma umanamente leggibile
    \item \textbf{Identificatore}: un'etichetta unica fornita dal file system per distinguere i file
    \item \textbf{Tipo}: tpo di dati contenuti nel file (alcuni S.O. non hanno questo attributo)
    \item \textbf{Locazione}: dispositivo di memoria secondaria e posizione nel dispositivo dove l'informazione del file è memorizzata
    \item \textbf{Dimensione}: in byte, parole, record, ...
    \item \textbf{Protezione}: informazione di controllo accessi
    \item \textbf{Ora, data e utente} che ha creato, letto o modificato per ultimo il file
    \item \textbf{Attributi estesi}: checksum, codifica caratteri, applicazioni correlate ecc...
\end{itemize}
Le informazioni sul file sono memorizzate nelle \textbf{directory}.
\subsection{Operazioni dei processi sui file}
I processi possono effettuare le seguenti operazioni sui file:
\begin{itemize}
    \item \textbf{Creazione}: viene riservato spazio nel file system per i dati, e viene aggiunto un elemento nella directory
    \item \textbf{Apertura}: effettuata prima dell'utilizzo del file
    \item \textbf{Lettura}: a partire dalla posizione determinata da un puntatore di lettura
    \item \textbf{Scrittura}: a partire dalla posizione determinata da un puntatore di scrittura (di solito coincide con il puntatore di lettura)
    \item \textbf{Riposizionamento (seek)}: spostamento del puntatore all'interno del file
    \item \textbf{Chiusura}: effettuata alla fine dell'utilizzo del file
    \item \textbf{Cancellazione e troncamento}: il troncamento canella i dati \textbf{ma non il file} con i suoi attributi
\end{itemize}
\subsection{Lock dei file}
Uno stesso file può essere aperto \textbf{contemporaneamente da più processi che operano in concorrenza}.
Alcuni sistemi operativi permettono di associare ai file (o a porzioni di esso) dei \textbf{lock} per coordinare i processi che operano sullo stesso file.
Vi sono due tipi di lock:
\begin{itemize}
    \item \textbf{Lock condiviso}: detto anche \textbf{lock di lettura}; più processi possono acquisirlo, proibisce l'acquisizione di un lock esclusivo
    \item \textbf{Lock esclusivo}: detto anche \textbf{lock di scrittura}; solo un processo alla volta può acquisirlo, proibisce l'acquisizione di un lock condiviso
\end{itemize}
Altre possibilità sono:
\begin{itemize}
    \item \textbf{Lock obbligatori (mandatory)}: il sistema operativo proibisce l'accesso al file ai processi che \textbf{non detengono il lock}
    \item \textbf{Lock consultivi (advisory)}: il sistema operativo \textbf{offre il lock} ma non regola l'accesso al file: sono i processi che devono evitare di accedere al file se non hanno il lock
\end{itemize}
I sistemi \textbf{Windows} adottano i lock obbligatori, i sistemi \textbf{Unix-life} i lock consultivi.
\subsection{Tipi di file}
Vi sono principalmente due tipi di file:
\begin{itemize}
    \item Dati (numerici, testo, binari)
    \item Programmi
\end{itemize}
Il sistema operativo può essere più o meno consapevole del tipo di file, \textbf{ma deve almeno riconoscere il tipo di file eseguibile}.
Possibili tecniche per riconoscere il tipo di file sono:
\begin{itemize}
    \item Schema del nome (nome.estensione)
    \item Attributi nel file (ad esempio in macOS, viene registrato il programma che ha creato il file)
    \item "Magic Number" all'inizio del file (ad esempio la "shebang" magic cookie ("\#!") all'inizio degli script Unix)
\end{itemize}
\subsection{Struttura dei file}
I file possono avere o meno una struttura ben definita; alcune possibilità sono:
\begin{itemize}
    \item Nessuna struttura (ad esempio, nei sistemi Unix-like un file è una sequenza di byte)
    \item \textbf{Sequenza di record} (righe di testo o record binari, a struttura e lunghezza fissa o variabile)
    \item \textbf{Strutture più complesse e standardizzate}, sopratutto per i file eseguibili (formato PE in Windows, a.out ed ELF nei sistemi Unix-like, Mach-O in macOS)
\end{itemize}
Più il sistema operativo supporta direttamente diverse strutture di file, \textbf{più diventa complesso}.
Inoltre se il sistema operativo è troppo "rigido" sulle possibili strutture, potrebbe non supportare nuovi tipi, o tipi \textbf{ibridi}.
\subsection{Metodi di accesso a file}
Vediamo ora quali possono essere i principali metodi di accesso ad un file
\subsubsection{Accesso sequenziale}
In questo tipo di accesso, il file \textbf{è una sequenza di record a lunghezza fissa}
\begin{center}
    \includegraphics[width = 0.50\linewidth]{Images/24.png}
\end{center}
Le operazioni disponibili in questo caso sono:
\begin{itemize}
    \item \textit{read\_next()} e \textit{write\_next()} leggono/scrivono il successivo record dalla posizione corrente
    \item Operazione di \textbf{riavvolgimento}
\end{itemize}
\subsubsection{Accesso diretto}
In questo tipo di accesso, abbiamo a disposizione le seguenti operazioni:
\begin{itemize}
    \item Operazioni \textit{read(n)} e \textit{write(n)} per accedere direttamente all'n-esimo record
    \item Alternativamente, possiamo usare \textit{read\_next(), write\_next()} e \textit{position(n)}
\end{itemize}
\subsubsection{Accesso indicizzato}
In alcuni sistemi operativi, ad esempio quelli per mainframe IBM, i file possono essere \textbf{sequenze di record ordinate secondo un determinato campo chiave del record}.
In tali sistemi, l'accesso può essere basato \textbf{sulla chiave}, e il sistema operativo mantiene un indice per velocizzare l'accesso. Esempio è \textbf{l'accesso ISAM} (Indexed Sequential Access Method) nei sistemi IBM,
file systems \textbf{Files-11} prodotto da Digital per il sistema operativo OpenVMS (offre tutti e tre i tipi di accesso su record a lunghezza fissa o variabile).
\subsection{Directories}
Una \textbf{directory} è, in pratica, un elenco di file presenti nel file system.
Più formalmente, \textbf{è una tabella} che permette di associare il nome di un file ai dati (e metadati) contenuti nel file stesso.
Sia i file che le directory risiedono sul disco: deve esservi \textbf{almeno una directory nel file system} (altrimenti non sarebbe possibile ritrovare i file!)
I processi possono effettuare le seguenti operazioni sulle directory:
\begin{itemize}
    \item \textbf{Creazione} di un file in una directory
    \item \textbf{Cancellazione} di un file in una directory
    \item \textbf{Ridenominazione} di un file o \textbf{spostamento} da una directory ad un'altra
    \item \textbf{Elenco} dei file in una directory
    \item \textbf{Ricerca} di un file: basata sul nome, o suno schema di possibili nomi
    \item \textbf{Attraversamento} del file system, ad esempio per effettuare un backup
\end{itemize}
Le directories possono avere diversi tipi di struttura:
\begin{itemize}
    \item Ad un livello
    \item A due livelli
    \item Ad albero
    \item A grafo aciclico
    \item A grafo generale
\end{itemize}
\subsubsection{Struttra delle directory ad un livello}
\begin{center}
    \includegraphics[width = 0.60\linewidth]{Images/25.png}
\end{center}
Nella struttura ad un livello, \textbf{esiste una sola directory per tutti i file}.
Il vantaggio di questa struttura è la \textbf{semplicità}, tuttavia ha diversi svantaggi:
\begin{itemize}
    \item Difficoltà nel nominare i file quando sono molti
    \item Difficoltà nel raggruppare i file per utenti diversi
\end{itemize}
\subsubsection{Struttura delle directory a due livelli}
\begin{center}
    \includegraphics[width = 0.70\linewidth]{Images/26.png}
\end{center}
Nella struttura a due livelli, la directory principale \textbf{contiene delle sottodirectory, una per ogni utente}.
La sottodirectory utente contiene i \textbf{file dell'utente}; utenti diversi possono quindi dare \textbf{lo stesso nome a file diversi}.
Occore quindi usare dei \textbf{nomi di percorso (path name)} per identificare un file univocamente:
\begin{itemize}
    \item \textit{/user2/data} (separatori Unix-like)
    \item \textit{\textbackslash user2 \textbackslash data} (separatori Windows like)
    \item \textit{>user2>data} (separatori MULTICS-like)
\end{itemize}
I file di sistema sono di solito posti \textbf{in una o più directory speciali}, e occorre che il sistema conosca un \textbf{percorso di ricerca} per trovarli.
\subsubsection{Struttura delle directory ad albero}
\begin{center}
    \includegraphics[width = 0.60\linewidth]{Images/27.png}
\end{center}
Nella struttura ad albero, ogni directory \textbf{contiene ricorsivamente files e altre directory}. Questa struttura quindi
permette agli utenti di \textbf{raggruppare i propri file}. Per semplificare l'accesso, ad ogni programma è assegnata una \textbf{directory corrente}, dalla quale si possono specificare
\textbf{path relativi}
\begin{itemize}
    \item Esempio: se la directory corrente è \textit{/programs/mail}, un path relativo potrebbe essere \textit{prt/first}
\end{itemize}
In questo caso, come avviene la cancellazione della directory?
\begin{itemize}
    \item Con la directory \textbf{cancello tutto il suo contenuto}
    \item Oppure permetto di cancellare una directory \textbf{solo se è vuota}. Questa soluzione è la più sicura
\end{itemize}
\subsubsection{Struttra delle directory a grafo aciclico}
\begin{center}
    \includegraphics[width = 0.50\linewidth]{Images/28.png}
\end{center}
La struttura a grafo aciclico \textbf{permette l'aliasing} (più di un nome per lo stesso file).
Cosa succede però se \textbf{cancello un file/directory con un alias?}
\begin{itemize}
    \item \textbf{Hard links}: duplicazione voci di directory; viene introdotto un \textbf{contatore} ai riferimenti, quando è a zero viene \textbf{cancellato il file}
    \item \textbf{Link simbolici}: riferimenti simbolici ad un \textbf{path assoluto}, quando questo è cancellato restano \textbf{dangling}; non sono aggiunti al contatore dei riferimenti
\end{itemize}
Questo tipo di struttura delle directory introduce anche un \textbf{problema di attraversamento del file system}.
\subsubsection{Struttura delle directory a grafo generico}
\begin{center}
    \includegraphics[width = 0.60\linewidth]{Images/29.png}
\end{center}
In questa struttura, vi è la possibilità di \textbf{hard links anche a directory a livelli superiori}, persino che contengono \textbf{ricorsivamente il link stesso}.
Per determinare se un file non è più referenziato, \textbf{un contatore al numero di riferimenti non basta più} ma occorre un autentico algoritmo di \textbf{garbage collection}.
Attraversare il file system in questo tipo di struttura diventa quindi ancora più complesso.
\subsection{Protezione}
Le informazioni devono essere preservate dai danni fisici (affidabilità) e dagli accessi impropri (protezione).
Un sistema multiutente permette un \textbf{accesso controllato ai file} di un certo utente da parte degli altri utenti.
Le operazioni controllabili sono:
\begin{itemize}
    \item Lettura
    \item Scrittura
    \item Esecuzione
    \item Aggiunta (scrittura in coda ad un file)
    \item Cancellazione
    \item Elencazione (elenco del contenuto di una directory)
\end{itemize}
\subsubsection{Liste di controllo degli accessi}
L'idea questo tipo di protezione è la seguente:
\begin{itemize}
    \item Ad ogni file/directory è associata una \textbf{lista di controllo degli accessi} (access control list, ACL)
    \item l'ACL specifica gli utenti \textbf{che possono accedere al file/directory}, con i relativi permessi di accesso
    \item Il file system controlla l'ACL prima di ogni accesso al file
\end{itemize}
Il \textbf{principale svantaggio} di questo approccio è che le ACL \textbf{possono diventare molto lunghe}.
Nei sistemi Unix-like, l'approccio usato è \textbf{raggruppare gli utenti in classi distinte}:
\begin{itemize}
    \item \textbf{Proprietario}: l'utente che possiede il file/directory
    \item \textbf{Gruppo}: il gruppo di utenti che condivide il file/directory
    \item \textbf{Pubblico}: tutti gli altri utenti
\end{itemize}
Facciamo un esempio:
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|ccc|}
    \hline
    Gruppo       & Bit di permesso (base 10) & \multicolumn{1}{c|}{r} & \multicolumn{1}{c|}{w} & x \\ \hline
    Proprietario & 7                         & 1                      & 1                      & 1 \\
    Gruppo       & 6                         & 1                      & 1                      & 0 \\
    Pubblico     & 4                         & 1                      & 0                      & 0 \\ \hline
    \end{tabular}
\end{table}
\noindent
Supponiamo di avere un file \textit{game}, di volergli assegnare un gruppo G e di volergli attribuire i permessi di cui sopra.
Allora procediamo come segue:
\begin{itemize}
    \item \textit{chgrp G game  \# cambia gruppo al file game}
    \item \textit{chmod 764 game  \# cambia i permessi al file game}
\end{itemize}
\subsection{Volumi e montaggio}
Un sistema operativo deve permettere di aggiungere e rimuovere dinamicamente unità di memorizzazione dati.
Un dispositivo di archiviazione può essere suddiviso in \textbf{partizioni}:
\begin{center}
    \includegraphics[width = 0.80\linewidth]{Images/30.png}
\end{center}
Un \textbf{volume} è una \textbf{zona di un dispositivo di archiviazione contenete un file system}.
Un volume, di solito, è contenuto in una partizione, su un solo dispositivo,
ma per alcuni filesystem particolari, un volume si può \textbf{estendere su più partizioni/dispositivi}.
Il sistema operativo deve permette di \textbf{montare e smontare} un volume all'interno dello spazio dei nomi del file system.
Di solito per montare un volume occorre fornire al sistema operativo:
\begin{itemize}
    \item L'identificazione del dispositivo/partizione dove risiede il volume
    \item Il punto di montaggio, ossia la \textbf{locazione nella struttura di file e directory alla quale "agganciare" il file system contenuto nel volume} (tipicamente una directory vuota)
\end{itemize}
Esistono diverse varianti di questo meccanismo:
\begin{itemize}
    \item \textbf{Punto di montaggio}: directory vuota oppure no
    \item \textbf{Montaggio}: automatico o manuale
    \item \textbf{Utilizzo di identificatori (lettere) di unità} anziché punti di montaggio
    \item \textbf{Montaggio ripetuto di uno stesso volume permesso} oppure no
\end{itemize}
\begin{center}
    \includegraphics[width = 1\linewidth]{Images/31.png}
\end{center}
\subsection{API POSIX per operazioni sui file}
Per creare un file, possiamo utilizzare l'API \textit{creat}:
\begin{center}
    \textit{int creat(const char* path, mode\_t mode);}
\end{center}
Essa si comporta tuttavia come se fosse implementata nel seguente modo:
\begin{center}
    \includegraphics[width = 0.80\linewidth]{Images/32.png}
\end{center}
Quindi il parametro \textit{mode} dovrà assumere i valori delle flag presentate per \textit{open}. I valori
di ritorno della funzione saranno quindi quelli della funzione \textit{open}.
Per creare un file \textit{foot.txt} con diritti di lettura e scrittura per il proprietario, e di sola lettura per i membri
del gruppo e gli altri possiamo fare nel seguente modo:
\begin{center}
    \textit{int fd = creat("foo.txt", S\_IRUSR|S\_IWUSR|S\_IRGRP|S\_IROTH);}
\end{center}
oppure possiamo chiamare direttamente \textit{open}.
Per aprire un file, possiamo usare l'API \textit{open} (già presentata), mentre per leggere da un file
possiamo usare la funzione \textit{read} (già presentata).
Per scrivere su un file possiamo usare la funzione \textit{write} (già presentata), mentre per \textbf{riposizionarci all'interno di un file} possiamo usare
la funzione \textit{lseek}
\begin{center}
    \textit{off\_t lseek(int fildes, off\_t offset, int whence);}
\end{center}
La funzione riposizionerà il puntatore per il file aperto associato al file descriptor \textit{fildes} nel seguente modo:
\begin{itemize}
    \item Se \textit{whence} ha valore \textit{SEEK\_SET}, il puntatore sarà impostato al byte \textit{offset}
    \item Se \textit{whence} ha valore \textit{SEEK\_CUR}, il puntatore sarà impostato al byte corrispondente alla somma della posizione corrente e di \textit{offset}
    \item Se \textit{whence} ha valore \textit{SEEK\_END}, il puntatore sarà impostato alla fine del file più \textit{offset}
    \item Se \textit{whence} ha valore \textit{SEEK\_HOLE}, il puntatore sarà impostato alla prima posizione con un "buco" (regione del file senza dati) con grandezza maggiore o uguale a \textit{offset}, a meno che \textit{offset} non cada oltre l'ultimo byte non all'interno di un buco; in questo caso, il puntatore viene impostato all'ultimo byte del file (cioè, c'e sempre un buco implicito alla fine di ogni file)
    \item Se \textit{whence} ha valore \textit{SEEK\_DATA}, il puntatore sarà impostato alla più piccola posizione di un byte che NON è in un buco a distanza minima \textit{offset} dalla posizione corrente. Verrà dato errore se questo byte non esiste
\end{itemize}
Le flag appena presentate sono presenti nella libreria \textit{unistd.h}.
Un esempio del suo utilizzo è il seguente:
\begin{center}
    \textit{off\_t offset = lseek(fd, 10, SEEK\_CUR); // 10 bytes dopo la posizione corrente}
\end{center}
La funzione ritornerà l'offset risultante, misurato in byte dall'inizio del file, se ha successo, altrimenti -1.
Per chiudere un file utilizziamo l'API \textit{close} (già presentata), mentre per cancellarlo dal file system usiamo l'API \textit{unlink} (già presentata).
Per troncare un file invece fino ad una lunghezza $n$, possiamo usare la funzione \textit{truncate}:
\begin{center}
    \textit{int truncate(const char* path, off\_t length);}
\end{center}
La funzione quindi troncherà il file identificato dal path \textit{path} fino alla posizione \textit{length} (cioè imposta la sua lunghezza a \textit{length}).
I dati presenti dopo \textit{length} sono \textbf{scartati}. La funzione ritornerà 0 se ha successo, -1 altrimenti. Un esempio del suo uso può essere il seguente:
\begin{center}
    \textit{int ok = truncate("foo.txt", n); //tronca il file alla lunghezza n}
\end{center}
\subsubsection{API POSIX per i lock}
In POSIX, i lock sui file sono \textbf{consultivi}. Il lock su un file si può effettuare con l'operazione \textit{fcntl}, che è un API che permette di effettuare \textbf{diversi tipi di operazioni sui file}. La sua firma è:
\begin{center}
    \textit{int fcntl(int fildes, int cmd, ...);}
\end{center}
Essa ha parecchie funzionalità, quindi qui ci concentreremo solo su quelle necessarie per effettuare un lock.
Occorre specificare il tipo di lock utilizzando una \textbf{struct flock}. Se si vuole effetutare un lock su un file puntato da \textit{fildes}, l'argomento di \textit{cmd} dovrà essere
\textit{F\_SETLK}. Vediamo un esempio:
\begin{center}
    \textit{struct flock fl;} \\
    \textit{fl.l\_type = F\_RDLCK; // read lock} \\
    \textit{fl.l\_whence = SEEK\_CUR; // dalla posizione corrente...} \\
    \textit{fl.l\_start = 10; //...più 10 byte} \\
    \textit{fl.l\_len = 0; //fino alla fine del file} \\
    \textit{int ok = fcntl(fd, F\_SETLK, \textnormal{\&}fl); // se non riesce ad impostare un lock, fallisce}
\end{center}
\subsection{API POSIX per operazioni su directory}
Per creare una nuova directory, possiamo usare la funzione \textit{mkdir}
\begin{center}
    \textit{int mkdir(const char* path, mode\_t mode);}
\end{center}
Essa creerà una nuova directory con nome \textit{path}. Il parametro \textit{mode} indica i bit di permesso per la nuova directory.
Per esempio, creiamo una nuova directory, con diritti di lettura, scrittura e ricerca per il proprietario e di sola lettura per i membri del gruppo e gli altri nel seguente modo:
\begin{center}
    \textit{mkdir("/home/pietro/newdir", S\_IRWXU|S\_IRGRP|S\_IROTH);}
\end{center}
La funzione restituisce 0 se ha successo, -1 altrimenti. Come si può notare, possiamo anche usare le flag viste in precedenza, concatenare con un bitwise inclusive OR (|), per specificare
i permessi. Per eliminare una directory (solo se vuota) possiamo usare la funzione \textit{rmdir}:
\begin{center}
    \textit{int rmdir(const char* path);}
\end{center}
La funzione rimuoverà la directory specificata da \textit{path}. Ritorna 0 se ha successo, -1 altrimenti. Un esempio di un suo utilizzo può essere il seguente:
\begin{center}
    \textit{rmdir("/home/pietro/newdir");}
\end{center}
Possiamo aprire una directory tramite l'API \textit{opendir}:
\begin{center}
    \textit{DIR *opendir(const char *dirname);}
\end{center}
La funzione aprirà la directory specificata da \textit{dirname} (in particolare, apre un \textbf{directory stream}, che è una sequenza ordinata di tutte le voci in una directory). La funzione ritornerà un \textbf{puntatore ad una struttura di tipo DIR} (cioè un puntatore al directory stream)
se ha successo, altrimenti ritornerà un puntatore a null. Per leggere da una directory possiamo usare l'API \textit{readdir}:
\begin{center}
    \textit{struct dirent* readdir(DIR *dirp);}
\end{center}
La funzione ritornerà un puntatore ad una struttura \textit{dirent}, definita in \textit{dirent.h}, che rappresenta la voce nella directory alla posizione corrente nello stream specificato nell'argomento \textit{dirp}; dopodiche posizionerà
lo stream \textbf{alla prossima voce della directory}. Se la funzione incontra un errore oppure arriva alla fine della directory, ritornerà un puntatore a null.
Per cambiare il nome, o spostare, un file o una directory si può usare l'API \textit{link} in combinazione con l'API \textit{unlink}. Presentiamo prima la firma di \textit{link}:
\begin{center}
    \textit{int link(const char* path1, const char* path2);}
\end{center} 
La funzione creerà un nuovo \textbf{hard link} nel percorso \textit{path2} per il file 
identificato dal \textit{path1}. La funzione ritorna 0 se ha successo, -1 altrimenti.
Per ottenere l'effetto descritto sopra, possiamo fare come segue: supponiamo di voler spostare il file \textit{/foo/bar} nella directory \textit{/home/pietro}
e, allo stesso tempo, cambiare il suo nome in \textit{baz}:
\begin{center}
    \textit{int ok1 = link("/foo/bar", "/home/pietro/baz");} \\
    \textit{int ok2 = unlink("/foo/bar");}
\end{center}
Quando il link count di un file \textbf{arriva a zero}, il file \textbf{viene cancellato}.
Per creare un link simbolico, possiamo usare l'API \textit{symlink}:
\begin{center}
    \textit{int symlink(const char* path1, const char* path2);}
\end{center}
La funzione creerà un link simbolico chiamato \textit{path2} per il file con path \textit{path1}. Facciamo un esempio:
\begin{center}
    \textit{int ok = symlink("/home/pietro/baz", "/home/pietro/alias");}
\end{center}
I link simbolici non vengono aggiunti al link count.
\subsection{API POSIX per la protezione}
In POSIX, la protezione è basata su bit di lettura/scrittura/esecuzione per i gruppi proprietario/gruppo/pubblico.
Per cambiare il proprietario eil gruppo di un file possiamo usare la funzione \textit{chown}:
\begin{center}
    \textit{int chown(const char *path, uid\_t owner, gid\_t group);}
\end{center}
La funzione imposterà per il file in \textit{path} \textit{owner} come nuovo proprietario del file e \textit{group} come nuovo gruppo di appartenenza.
La funzone ritorna 0 se ha successo, -1 altrimenti.
Facciamo un esempio:
\begin{center}
    \textit{uid\_t owner = ...; // Un nuovo proprietario} \\
    \textit{gid\_t group = ...; // Un nuovo gruppo di appartenenza} \\
    \textit{int ok = chown("/home/pietro/baz, owner, group);}
\end{center}
Per cambiare i diritti di lettura/scrittura/esecuzione, possiamo usare la funzione \textit{chmod}:
\begin{center}
    \textit{int chmod(const char* path, mode\_t mode);}
\end{center}
La funzione imposterà i nuovi bit di permesso per il file in \textit{path} a \textit{mode}, la quale può essere
descritta con le flag viste fino ad ora per \textit{mode}, concatenate con un bitwise inclusive OR. Facciamo un esempio:
\begin{center}
    \textit{int ok = chmdo("/home/pietro/baz", S\_IRUSR | S\_IRGRP);}
\end{center}
la funzione ritornerà 0 se ha successo, -1 altrimenti.
\end{document}
